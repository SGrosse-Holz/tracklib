
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tracklib.models &#8212; tracklib 0.1 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="tracklib.util" href="tracklib.util.html" />
    <link rel="prev" title="tracklib.io" href="tracklib.io.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tracklib.util.html" title="tracklib.util"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tracklib.io.html" title="tracklib.io"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">tracklib 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tracklib.html" accesskey="U">tracklib</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tracklib-models">
<h1>tracklib.models<a class="headerlink" href="#tracklib-models" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#module-tracklib.models.rouse" id="id1">tracklib.models.rouse</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.models.statgauss" id="id2">tracklib.models.statgauss</a></p></li>
</ul>
</div>
<div class="section" id="module-tracklib.models.rouse">
<span id="tracklib-models-rouse"></span><h2><a class="toc-backref" href="#id1">tracklib.models.rouse</a><a class="headerlink" href="#module-tracklib.models.rouse" title="Permalink to this headline">¶</a></h2>
<p>This module provides an implementation of the Rouse model.</p>
<p>Its content is mostly the <a class="reference internal" href="#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> class, so see there for more description.
Otherwise, there is the functional form for the MSD of two loci on an infinite
continuous Rouse polymer in <a class="reference internal" href="#tracklib.models.rouse.twoLocusMSD" title="tracklib.models.rouse.twoLocusMSD"><code class="xref any py py-func docutils literal notranslate"><span class="pre">twoLocusMSD</span></code></a>. This might be used as
phenomenological expression for fitting to data.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Model</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">msdfit</span></code></p>
</div>
<dl class="class">
<dt id="tracklib.models.rouse.Model">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.models.rouse.</code><code class="sig-name descname">Model</code><span class="sig-paren">(</span><em class="sig-param">N</em>, <em class="sig-param">D=1.0</em>, <em class="sig-param">k=1.0</em>, <em class="sig-param">d=3</em>, <em class="sig-param">setup_dynamics=True</em>, <em class="sig-param">add_bonds=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Rouse model</p>
<p>This model follows the linear Langevin equation</p>
<div class="math notranslate nohighlight">
\[\dot{x}(t) = Ax(t) + F + \xi(t)\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is a vector of monomer positions and <span class="math notranslate nohighlight">\(\xi\)</span> is
Gaussian white noise of strength proportional <a class="reference internal" href="#tracklib.models.rouse.Model.D" title="tracklib.models.rouse.Model.D"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">D</span></code></a> driving the system. The
connectivity matrix <span class="math notranslate nohighlight">\(A\)</span> describes which monomers are connected to
which by harmonic bonds with spring constant <a class="reference internal" href="#tracklib.models.rouse.Model.k" title="tracklib.models.rouse.Model.k"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">k</span></code></a>. The connectivity matrix
is conveniently set up using <a class="reference internal" href="#tracklib.models.rouse.Model.setup_free_chain" title="tracklib.models.rouse.Model.setup_free_chain"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">setup_free_chain</span></code></a> and <a class="reference internal" href="#tracklib.models.rouse.Model.add_crosslinks" title="tracklib.models.rouse.Model.add_crosslinks"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">add_crosslinks</span></code></a>.
Finally, <span class="math notranslate nohighlight">\(F\)</span> can be used to incorporate an external force on
individual monomers.</p>
<p>This model implementation provides the following functionality:</p>
<ul class="simple">
<li><p>setting up a spring network with arbitrary connectivity matrix</p></li>
<li><p>calculating the steady state ensemble.</p></li>
<li><p>propagating an arbitrary Gaussian ensemble forward in time</p></li>
<li><p>evolving a single conformation <span class="math notranslate nohighlight">\(x\)</span> forward in time</p></li>
<li><p>analytically calculating MSD &amp; ACF, also for arbitrary linear
combinations of loci (e.g. MSD of the vector between two loci)</p></li>
<li><p>other auxiliary stuff, like giving equilibration time scales and contact
probabilities</p></li>
</ul>
<dl class="attribute">
<dt id="tracklib.models.rouse.Model.N">
<code class="sig-name descname">N</code><a class="headerlink" href="#tracklib.models.rouse.Model.N" title="Permalink to this definition">¶</a></dt>
<dd><p>number of monomers</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.models.rouse.Model.D">
<code class="sig-name descname">D</code><a class="headerlink" href="#tracklib.models.rouse.Model.D" title="Permalink to this definition">¶</a></dt>
<dd><p>diffusivity of an individual monomer (i.e. strength of the driving
white noise)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.models.rouse.Model.k">
<code class="sig-name descname">k</code><a class="headerlink" href="#tracklib.models.rouse.Model.k" title="Permalink to this definition">¶</a></dt>
<dd><p>default spring constant for harmonic bonds</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.models.rouse.Model.d">
<code class="sig-name descname">d</code><a class="headerlink" href="#tracklib.models.rouse.Model.d" title="Permalink to this definition">¶</a></dt>
<dd><p>spatial dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.models.rouse.Model.A">
<code class="sig-name descname">A</code><a class="headerlink" href="#tracklib.models.rouse.Model.A" title="Permalink to this definition">¶</a></dt>
<dd><p>connectivity matrix. Initialized to a linear polymer by default</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(N, N) array, dtype=float, internal</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.models.rouse.Model.F">
<code class="sig-name descname">F</code><a class="headerlink" href="#tracklib.models.rouse.Model.F" title="Permalink to this definition">¶</a></dt>
<dd><p>deterministic external force on each monomer. Zero by default</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(N, d) array, dtype=float, internal</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>setup_dynamics</strong> (<em>bool</em>) – whether to pre-calculate matrices needed for dynamics (propagation of
ensembles / evolution of single conformation).</p></li>
<li><p><strong>add_bonds</strong> (<em>list of bonds</em>) – shortcut for adding bonds to the system before initializing dynamics.
Corresponds to the <code class="xref any docutils literal notranslate"><span class="pre">links</span></code> argument of <a class="reference internal" href="#tracklib.models.rouse.Model.add_crosslinks" title="tracklib.models.rouse.Model.add_crosslinks"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">add_crosslinks</span></code></a>, see there for
more details.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">d</code></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.setup_free_chain">
<code class="sig-name descname">setup_free_chain</code><span class="sig-paren">(</span><em class="sig-param">d=3</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.setup_free_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up connectivity matrix of a linear chain and zero external force</p>
<p>Mostly used internally upon initialization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> (<em>int</em>) – spatial dimension</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.add_crosslinks" title="tracklib.models.rouse.Model.add_crosslinks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_crosslinks()</span></code></a>, <a class="reference internal" href="#tracklib.models.rouse.Model.add_tether" title="tracklib.models.rouse.Model.add_tether"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_tether()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.add_crosslinks">
<code class="sig-name descname">add_crosslinks</code><span class="sig-paren">(</span><em class="sig-param">links</em>, <em class="sig-param">k_rel=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.add_crosslinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Add additional bonds to connectivity matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>links</strong> (<em>list of</em><em> (</em><em>monA</em><em>, </em><em>monB</em><em>, </em><em>k_rel</em><em>) or </em><em>(</em><em>monA</em><em>, </em><em>monB</em><em>) </em><em>tuples</em>) – bonds to add. Introduces an additional bond between <code class="docutils literal notranslate"><span class="pre">monA</span></code> and
<code class="docutils literal notranslate"><span class="pre">monB</span></code> (integer indices &lt; <a class="reference internal" href="#tracklib.models.rouse.Model.N" title="tracklib.models.rouse.Model.N"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">N</span></code></a>) of strength <code class="docutils literal notranslate"><span class="pre">k_rel*k</span></code>. Giving
<code class="docutils literal notranslate"><span class="pre">k_rel</span></code> as third entry in the tuple overwrites use of the
function argument <code class="xref any docutils literal notranslate"><span class="pre">k_rel</span></code> for this bond.</p></li>
<li><p><strong>k_rel</strong> (<em>float &gt; 0</em><em>, </em><em>optional</em>) – strength of the new bonds, as multiple of the class attribute <code class="xref any docutils literal notranslate"><span class="pre">k</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.add_tether" title="tracklib.models.rouse.Model.add_tether"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_tether()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.add_tether">
<code class="sig-name descname">add_tether</code><span class="sig-paren">(</span><em class="sig-param">mon=0</em>, <em class="sig-param">k_rel=1.0</em>, <em class="sig-param">point=(0.0</em>, <em class="sig-param">0.0</em>, <em class="sig-param">0.0)</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.add_tether" title="Permalink to this definition">¶</a></dt>
<dd><p>Tether a monomer to a fixed point in space</p>
<p>This simply introduces an additional harmonic bond between this monomer
and the specified point. Note that you can give a large <code class="xref any docutils literal notranslate"><span class="pre">k_rel</span></code> to
actually pin the monomer in place</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon</strong> (<em>int</em>) – the index of the monomer that should get the tether</p></li>
<li><p><strong>k_rel</strong> (<em>float &gt; 0</em><em>, </em><em>optional</em>) – strength of the tether, in multiples of the default bond strength <code class="xref any docutils literal notranslate"><span class="pre">k</span></code>.</p></li>
<li><p><strong>point</strong> (<em>(</em><em>d</em><em>,</em><em>) </em><em>array-like</em>) – the point to tether to</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.add_crosslinks" title="tracklib.models.rouse.Model.add_crosslinks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_crosslinks()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.update_dynamics">
<code class="sig-name descname">update_dynamics</code><span class="sig-paren">(</span><em class="sig-param">dt=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.update_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-calculate dynamic matrices</p>
<p>This sets the model up for evaluation of model dynamics, such as
evolving a conformation or propagating an ensemble. It should be called
after any modification to model parameters, which is handled
automatically for internal modifications (such as when <a class="reference internal" href="#tracklib.models.rouse.Model.add_crosslinks" title="tracklib.models.rouse.Model.add_crosslinks"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">add_crosslinks</span></code></a>
is called). If you modify anything externally, recommended behavior is
to simply set <code class="docutils literal notranslate"><span class="pre">model._dynamics['needs_updating']</span> <span class="pre">=</span> <span class="pre">True</span></code>, which will
ensure that stuff is recalculated as needed.</p>
<p>Ultimately, this is just a wrapper for the <code class="docutils literal notranslate"><span class="pre">update_*</span></code> functions. If
you know what you’re doing, you can also just call these individually
as needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dt</strong> (<em>float</em>) – time step to prepare for</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.check_dynamics" title="tracklib.models.rouse.Model.check_dynamics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check_dynamics()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.update_F_only">
<code class="sig-name descname">update_F_only</code><span class="sig-paren">(</span><em class="sig-param">override_full_update=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.update_F_only" title="Permalink to this definition">¶</a></dt>
<dd><p>Update specifically the stuff depending on the external force F.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>override_full_update</strong> (<em>bool</em>) – pretend that this was a full update. Useful when you changed only
<code class="xref any docutils literal notranslate"><span class="pre">F</span></code> since the last update, to avoid recalculating everything else</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.update_dynamics" title="tracklib.models.rouse.Model.update_dynamics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_dynamics()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.check_dynamics">
<code class="sig-name descname">check_dynamics</code><span class="sig-paren">(</span><em class="sig-param">dt=None</em>, <em class="sig-param">run_if_necessary=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.check_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that dynamics are set up properly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> (<em>float</em><em> or </em><em>None</em>) – the time step we should be set up for. Specify <code class="docutils literal notranslate"><span class="pre">None</span></code> to accept
whatever was the value set up</p></li>
<li><p><strong>run_if_necessary</strong> (<em>bool</em>) – controls the behavior when dynamics are not set up. If set to
<code class="docutils literal notranslate"><span class="pre">True</span></code> (default), <a class="reference internal" href="#tracklib.models.rouse.Model.update_dynamics" title="tracklib.models.rouse.Model.update_dynamics"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">update_dynamics</span></code></a> is simply run with the
settings we have. If set to <code class="docutils literal notranslate"><span class="pre">False</span></code> raise a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> if
dynamics are not (correctly) set up for the current model.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – if something is not set up properly</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.update_dynamics" title="tracklib.models.rouse.Model.update_dynamics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_dynamics()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.steady_state">
<code class="sig-name descname">steady_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.steady_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the steady state ensemble</p>
<p>Since our model is linear and driven by Gaussian noise, the steady
state ensemble will always be Gaussian, and as such given by a mean
vector and covariance matrix over all monomers.</p>
<p>We use the Moore-Penrose pseudo-inverse of the connectivity matrix
<code class="docutils literal notranslate"><span class="pre">A</span></code> to calculate the steady state distribution. This means that any
degrees of freedom (such as center of mass for a free chain) will be
pinned to the origin instead of diverging to infinity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>M</strong> (<em>(N, d) np.ndarray, dtype=float</em>) – mean position of each monomer</p></li>
<li><p><strong>C</strong> (<em>(N, N) np.ndarray, dtype=float</em>) – covariance between monomer coordinates in each dimension. Note that
we assume independence of spatial dimensions, such that the full
covariance <code class="docutils literal notranslate"><span class="pre">C_ijab</span> <span class="pre">:=</span> <span class="pre">&lt;x_ia*x_jb&gt;_c</span></code> (with monomer indices i, j
and spatial indices a, b) is written as the tensor product <code class="docutils literal notranslate"><span class="pre">C_ijab</span>
<span class="pre">=</span> <span class="pre">C_ij*δ_ab</span></code> with Kronecker’s δ. The matrix returned by this
function is <code class="docutils literal notranslate"><span class="pre">C_ij</span></code>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.propagate_M">
<code class="sig-name descname">propagate_M</code><span class="sig-paren">(</span><em class="sig-param">M</em>, <em class="sig-param">dt=None</em>, <em class="sig-param">check_dynamics=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.propagate_M" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate the mean of a Gaussian ensemble</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>(</em><em>N</em><em>, </em><em>d</em><em>) </em><em>np.ndarray</em><em>, </em><em>dtype=float</em>) – mean conformation</p></li>
<li><p><strong>dt</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – the time step to propagate for. When <code class="docutils literal notranslate"><span class="pre">None</span></code> uses the time step
set through <code class="docutils literal notranslate"><span class="pre">update_dynamics</span></code> (default, recommended)</p></li>
<li><p><strong>check_dynamics</strong> (<em>bool</em>) – whether to check for correct setup of precalculated matrices. Can
be disabled for performance when its otherwise clear that the setup
is correct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> (<em>(N, d) np.ndarray, dtype=float</em>) – like input <code class="xref any docutils literal notranslate"><span class="pre">M</span></code>, but propagated by <code class="xref any docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.propagate" title="tracklib.models.rouse.Model.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a>, <a class="reference internal" href="#tracklib.models.rouse.Model.propagate_C" title="tracklib.models.rouse.Model.propagate_C"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate_C()</span></code></a>, <a class="reference internal" href="#tracklib.models.rouse.Model.steady_state" title="tracklib.models.rouse.Model.steady_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">steady_state()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.propagate_C">
<code class="sig-name descname">propagate_C</code><span class="sig-paren">(</span><em class="sig-param">C</em>, <em class="sig-param">dt=None</em>, <em class="sig-param">check_dynamics=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.propagate_C" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate the covariance of a Gaussian ensemble</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>(</em><em>N</em><em>, </em><em>N</em><em>) </em><em>np.ndarray</em><em>, </em><em>dtype=float</em>) – current covariance</p></li>
<li><p><strong>dt</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – the time step to propagate for. When <code class="docutils literal notranslate"><span class="pre">None</span></code> uses the time step
set through <code class="docutils literal notranslate"><span class="pre">update_dynamics</span></code> (default, recommended)</p></li>
<li><p><strong>check_dynamics</strong> (<em>bool</em>) – whether to check for correct setup of precalculated matrices. Can
be disabled for performance when its otherwise clear that the setup
is correct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>C</strong> (<em>(N, N) np.ndarray, dtype=float</em>) – like input <code class="xref any docutils literal notranslate"><span class="pre">C</span></code>, but propagated by <code class="xref any docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.propagate" title="tracklib.models.rouse.Model.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a>, <a class="reference internal" href="#tracklib.models.rouse.Model.propagate_M" title="tracklib.models.rouse.Model.propagate_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate_M()</span></code></a>, <a class="reference internal" href="#tracklib.models.rouse.Model.steady_state" title="tracklib.models.rouse.Model.steady_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">steady_state()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.propagate">
<code class="sig-name descname">propagate</code><span class="sig-paren">(</span><em class="sig-param">M</em>, <em class="sig-param">C</em>, <em class="sig-param">dt=None</em>, <em class="sig-param">check_dynamics=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate a Gaussian ensemble one time step</p>
<p>This is simply a wrapper for <a class="reference internal" href="#tracklib.models.rouse.Model.propagate_M" title="tracklib.models.rouse.Model.propagate_M"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">propagate_M</span></code></a> and <a class="reference internal" href="#tracklib.models.rouse.Model.propagate_C" title="tracklib.models.rouse.Model.propagate_C"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">propagate_C</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>(</em><em>N</em><em>, </em><em>d</em><em>) </em><em>np.ndarray</em><em>, </em><em>dtype=float</em>) – current mean conformation</p></li>
<li><p><strong>C</strong> (<em>(</em><em>N</em><em>, </em><em>N</em><em>) </em><em>np.ndarray</em><em>, </em><em>dtype=float</em>) – current covariance</p></li>
<li><p><strong>dt</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – the time step to propagate for. When <code class="docutils literal notranslate"><span class="pre">None</span></code> uses the time step
set through <code class="docutils literal notranslate"><span class="pre">update_dynamics</span></code> (default, recommended)</p></li>
<li><p><strong>check_dynamics</strong> (<em>bool</em>) – whether to check for correct setup of precalculated matrices. Can
be disabled for performance when its otherwise clear that the setup
is correct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>M, C</em> – like input, but propagated by <code class="xref any docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.propagate_M" title="tracklib.models.rouse.Model.propagate_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate_M()</span></code></a>, <a class="reference internal" href="#tracklib.models.rouse.Model.propagate_C" title="tracklib.models.rouse.Model.propagate_C"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate_C()</span></code></a>, <a class="reference internal" href="#tracklib.models.rouse.Model.steady_state" title="tracklib.models.rouse.Model.steady_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">steady_state()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.conf_ss">
<code class="sig-name descname">conf_ss</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.conf_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a conformation from steady state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>(N, d) np.ndarray, dtype=float</em> – the drawn conformation</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.steady_state" title="tracklib.models.rouse.Model.steady_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">steady_state()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.evolve">
<code class="sig-name descname">evolve</code><span class="sig-paren">(</span><em class="sig-param">conf</em>, <em class="sig-param">dt=None</em>, <em class="sig-param">check_dynamics=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.evolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve a conformation forward one time step</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conf</strong> (<em>(</em><em>N</em><em>, </em><em>d</em><em>) </em><em>np.ndarray</em><em>, </em><em>dtype=float</em>) – the conformation to start from</p></li>
<li><p><strong>dt</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – the time step to propagate for. When <code class="docutils literal notranslate"><span class="pre">None</span></code> uses the time step
set through <code class="docutils literal notranslate"><span class="pre">update_dynamics</span></code> (default, recommended)</p></li>
<li><p><strong>check_dynamics</strong> (<em>bool</em>) – whether to check for correct setup of precalculated matrices. Can
be disabled for performance when its otherwise clear that the setup
is correct</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>conf</em> – like input, but evolved for <code class="xref any docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.conf_ss" title="tracklib.models.rouse.Model.conf_ss"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conf_ss()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.MSD">
<code class="sig-name descname">MSD</code><span class="sig-paren">(</span><em class="sig-param">dts</em>, <em class="sig-param">w=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.MSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate MSD for given degrees of freedom</p>
<p>This is simply an evaluation of analytical expressions. Which path
exactly we take depends on the system, see Notes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dts</strong> (<em>(</em><em>T</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>dtype=float</em>) – the time lags to evaluate the MSD at. Entries should be greater or
equal to zero</p></li>
<li><p><strong>w</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>np.ndarray</em><em>, </em><em>dtype=float</em>) – measurement vector. Use this to specify the linear combination of
monomers whose MSD you are interested in. See Examples. If
unspecified, the function returns the full covariance matrix at lag
Δt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>(T,) np.ndarray or (T, N, N) np.array</em> – the MSD, either as scalar function evaluated at <code class="xref any docutils literal notranslate"><span class="pre">dts</span></code> or matrix
valued (if no measurement vector <code class="xref any docutils literal notranslate"><span class="pre">w</span></code> was specified).</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The analytical solution for the MSD at time lag <span class="math notranslate nohighlight">\(\Delta t\)</span> is
given by</p>
<div class="math notranslate nohighlight">
\[MSD(\Delta t) \equiv \left\langle\left(x(t+\Delta t) - x(t)\right)^{\otimes 2}\right\rangle = V\left[ 2D E + (\Delta t)^2 SV^TF F^TVS \right] V^T\]</div>
<p>with <span class="math notranslate nohighlight">\(E = \int_0^{\Delta t}\mathrm{d}\tau\exp(-kA\tau)\)</span>, <code class="docutils literal notranslate"><span class="pre">S_ij</span> <span class="pre">=</span>
<span class="pre">1</span> <span class="pre">if</span> <span class="pre">i</span> <span class="pre">==</span> <span class="pre">j</span> <span class="pre">and</span> <span class="pre">λ_i</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">else</span> <span class="pre">0</span></code>, and <span class="math notranslate nohighlight">\(A = V\Lambda V.T\)</span> is the
eigendecomposition of A. Note that the Δt^2 terms just contributes
ballistic motion for force components acting on singular degrees of
freedom (e.g. center of mass).</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">... </span><span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span> <span class="c1"># some sample lag times</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Calculate full matrices. This is usually not as relevant</span>
<span class="gp">... </span><span class="n">msd</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">MSD</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># MSD of the middle monomer</span>
<span class="gp">... </span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
<span class="gp">... </span><span class="n">w</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">... </span><span class="n">msd</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">MSD</span><span class="p">(</span><span class="n">dts</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># MSD of the end-to-end vector</span>
<span class="gp">... </span><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
<span class="gp">... </span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span>  <span class="mi">1</span>
<span class="gp">... </span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">... </span><span class="n">msd</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">MSD</span><span class="p">(</span><span class="n">dts</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># The end-to-end dof equilibrates, so we can calculate the limit</span>
<span class="gp">... </span><span class="c1"># value</span>
<span class="gp">... </span><span class="n">msd_inf</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">MSD</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.ACF">
<code class="sig-name descname">ACF</code><span class="sig-paren">(</span><em class="sig-param">dts</em>, <em class="sig-param">w=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.ACF" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate autocovariances</p>
<p>Exists mostly for completeness. Calculates the autocovariance as <code class="docutils literal notranslate"><span class="pre">γ</span> <span class="pre">=</span>
<span class="pre">exp(-k*A*dt)</span> <span class="pre">&#64;</span> <span class="pre">C</span></code>, where <code class="docutils literal notranslate"><span class="pre">C</span></code> is the steady state covariance as
returned by <a class="reference internal" href="#tracklib.models.rouse.Model.steady_state" title="tracklib.models.rouse.Model.steady_state"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">steady_state()</span></code></a>. Note that for any equilibrating degrees
of freedom the ACF can also be calculated from the MSD as</p>
<blockquote>
<div><p>ACF(Δt) = 0.5*( MSD(∞) - MSD(Δt) )</p>
</div></blockquote>
<p>so sticking to the MSD is preferred. Any non-equilibrating dofs are
pinned to zero by the Moore-Penrose inverse.</p>
<p>The one benefit of this function over <a class="reference internal" href="#tracklib.models.rouse.Model.MSD" title="tracklib.models.rouse.Model.MSD"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">MSD</span></code></a> is that it is faster
(roughly 1.5x).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dts</strong> (<em>(</em><em>T</em><em>,</em><em>) </em><em>array-like</em><em>, </em><em>dtype=float</em>) – the time lags to evaluate the ACF at. Entries should be greater or
equal to zero</p></li>
<li><p><strong>w</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>np.ndarray</em><em>, </em><em>dtype=float</em>) – measurement vector. Use this to specify the linear combination of
monomers whose ACF you are interested in. If unspecified, the
function returns the full covariance matrix at lag Δt.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>(T,) np.ndarray or (T, N, N) np.array</em> – the ACF, either as scalar function evaluated at <code class="xref any docutils literal notranslate"><span class="pre">dts</span></code> or matrix
valued (if no measurement vector <code class="xref any docutils literal notranslate"><span class="pre">w</span></code> was specified).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.rouse.Model.MSD" title="tracklib.models.rouse.Model.MSD"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MSD()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.timescales">
<code class="sig-name descname">timescales</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.timescales" title="Permalink to this definition">¶</a></dt>
<dd><p>Give time scales relevant to the model</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>dict</em> – <code class="docutils literal notranslate"><span class="pre">t_microscopic</span></code> is where Rouse scaling (i.e. the model) starts to
apply; <code class="docutils literal notranslate"><span class="pre">t_Rouse</span></code> is the classic Rouse time (relaxation of the
slowest mode); <code class="docutils literal notranslate"><span class="pre">t_equilibration</span></code> is the actual crossover from
Rouse to equilibrium of the end-to-end distance (for a free chain)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.Gamma">
<code class="sig-name descname">Gamma</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.Gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>MSD prefactor of a single locus on the polymer</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>float</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.Gamma_2loci">
<code class="sig-name descname">Gamma_2loci</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.Gamma_2loci" title="Permalink to this definition">¶</a></dt>
<dd><p>MSD prefactor for distance between two loci</p>
<p>This is just <code class="docutils literal notranslate"><span class="pre">2*Gamma()</span></code>. Mostly serves as a reminder to include that
factor of two</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>float</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.rms_Ree">
<code class="sig-name descname">rms_Ree</code><span class="sig-paren">(</span><em class="sig-param">L=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.rms_Ree" title="Permalink to this definition">¶</a></dt>
<dd><p>RMS end-to-end distance for chain of length L</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>L</strong> (<em>float</em><em>, </em><em>optional</em>) – number of (effective) bonds in the chain. Defaults to <code class="docutils literal notranslate"><span class="pre">self.N-1</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.models.rouse.Model.contact_probability">
<code class="sig-name descname">contact_probability</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.Model.contact_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a contact probability matrix for the system</p>
<p>This is intended to produce HiC-like maps for the system. It is based
on the mean squared distance between each pair of loci, and then
converts to probability by a scaling exponent of <code class="docutils literal notranslate"><span class="pre">-self.d/2</span></code>. Note
that these are not actual probabilities, but relative frequencies</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>(N, N) np.ndarray, dtype=float</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="tracklib.models.rouse.twoLocusMSD">
<code class="sig-prename descclassname">tracklib.models.rouse.</code><code class="sig-name descname">twoLocusMSD</code><span class="sig-paren">(</span><em class="sig-param">dts</em>, <em class="sig-param">Gamma</em>, <em class="sig-param">J</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.rouse.twoLocusMSD" title="Permalink to this definition">¶</a></dt>
<dd><p>MSD for relative position of two loci on infinite continuous Rouse polymer</p>
<p>The analytical expression is given by</p>
<div class="math notranslate nohighlight">
\[MSD(\Delta t) = 2\Gamma\sqrt{\Delta t}\left(1 - \exp\left(-\frac{\tau}{\Delta t}\right)\right) + 2J\mathrm{erfc}\sqrt{\frac{\tau}{\Delta t}}\,,\]</div>
<p>with <span class="math notranslate nohighlight">\(\tau\equiv \frac{1}{\pi}\left(\frac{J}{\Gamma}\right)^2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dts</strong> (<em>array-like</em><em>, </em><em>dtype=float</em>) – the times at which to evaluate the MSD</p></li>
<li><p><strong>Gamma</strong> (<em>float</em>) – the prefactor for the polymer part (0.5 scaling) of the MSD. Note that
this parameter should be the prefactor for tracking of one locus, i.e.
the MSD produced by this function (which is the distance between two
loci) will have a prefactor of <code class="docutils literal notranslate"><span class="pre">2*Gamma</span></code>.</p></li>
<li><p><strong>J</strong> (<em>float</em>) – the mean squared distance of the two loci at steady state. This is half
the asymptotic value of the MSD: <code class="docutils literal notranslate"><span class="pre">MSD(Δt</span> <span class="pre">--&gt;</span> <span class="pre">inf)</span> <span class="pre">=</span> <span class="pre">2*J</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>(T,) np.array</em> – the MSD evaluated at times <code class="xref any docutils literal notranslate"><span class="pre">dts</span></code></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-tracklib.models.statgauss">
<span id="tracklib-models-statgauss"></span><h2><a class="toc-backref" href="#id2">tracklib.models.statgauss</a><a class="headerlink" href="#module-tracklib.models.statgauss" title="Permalink to this headline">¶</a></h2>
<p>This module provides a useful way to sample from a stationary Gaussian process.</p>
<p>By assuming stationary, Gaussian, mean-zero increments, the process is uniquely
defined by its MSD. Here we use that observation to generate sample traces from
such processes, given the MSD.</p>
<dl class="function">
<dt id="tracklib.models.statgauss.sampleMSD">
<code class="sig-prename descclassname">tracklib.models.statgauss.</code><code class="sig-name descname">sampleMSD</code><span class="sig-paren">(</span><em class="sig-param">msd</em>, <em class="sig-param">n=1</em>, <em class="sig-param">isCorr=False</em>, <em class="sig-param">subtractMean=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.statgauss.sampleMSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample traces from a stationary Gaussian process with given MSD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msd</strong> (<em>(</em><em>N</em><em>, </em><em>) </em><em>np.array</em>) – the MSD from which to sample. We use the convention that <code class="docutils literal notranslate"><span class="pre">msd[t]</span></code>
should be the MSD at time lag <code class="docutils literal notranslate"><span class="pre">t</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">msd[0]</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p></li>
<li><p><strong>n</strong> (<em>integer</em><em>, </em><em>optional</em>) – Number of traces to generate</p></li>
<li><p><strong>isCorr</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether the input array is MSD (default) or autocorrelation.</p></li>
<li><p><strong>subtractMean</strong> (<em>bool</em>) – whether to subtract the mean of each trace. See Notes below.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>traj</strong> (<em>(N, n) array</em>) – The generated traces.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.statgauss.dataset" title="tracklib.models.statgauss.dataset"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataset()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Strictly speaking, only the ensemble of displacements is well-defined,
because this is the one we assume steady state for. For the actual traces,
we can add an arbitrary offset, and the reasonable thing to do here depends
on the process we are sampling. For a purely diffusive process for example
it makes sense to have them all start from zero, since there is no steady
state anyways. If however, we are sampling from an MSD that plateaus at
long times, we basically also have a steady state for the traces and thus
the long-run mean converges.  In that case of course it makes sense to have
this mean be identical for all traces. The option <code class="xref any docutils literal notranslate"><span class="pre">subtractMean</span></code> does
exactly this: if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we subtract the mean from all generated traces,
i.e. fix the ensemble mean to zero. Note that this is not precisely correct
for finite-length traces, but probably the best we can do.</p>
<p><strong>Algorithm:</strong> from the MSD <span class="math notranslate nohighlight">\(\mu(k)\)</span> we calculate the increment
autocorrelation function <span class="math notranslate nohighlight">\(\gamma(k)\)</span> as</p>
<div class="math notranslate nohighlight">
\[\gamma(k) = \frac{1}{2} \left( \mu(|k+1|) + \mu(|k-1|) - 2\mu(|k|) \right) \,.\]</div>
<p>The covariance matrix of the increment process we want to sample from is
then the Toeplitz matrix with diagonals <span class="math notranslate nohighlight">\(\gamma(k)\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.models.statgauss.dataset">
<code class="sig-prename descclassname">tracklib.models.statgauss.</code><code class="sig-name descname">dataset</code><span class="sig-paren">(</span><em class="sig-param">msd</em>, <em class="sig-param">N=1</em>, <em class="sig-param">Ts=None</em>, <em class="sig-param">d=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.statgauss.dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a dataset of MSD sampled trajectories.</p>
<p>All keyword arguments not mentioned below will be forwarded to <a class="reference internal" href="#tracklib.models.statgauss.sampleMSD" title="tracklib.models.statgauss.sampleMSD"><code class="xref any py py-func docutils literal notranslate"><span class="pre">sampleMSD</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msd</strong> (<em>(</em><em>N</em><em>,</em><em>) </em><em>np.ndarray</em>) – the MSD to sample from.</p></li>
<li><p><strong>N</strong> (<em>int</em><em>, </em><em>optional</em>) – number of particles per trajectory</p></li>
<li><p><strong>Ts</strong> (<em>list of int</em><em>, </em><em>optional</em>) – list of trajectory lengths, i.e. this determines number and length of
trajectories. Any <code class="docutils literal notranslate"><span class="pre">None</span></code> entry will be replaced by the maximum possible
value, <code class="docutils literal notranslate"><span class="pre">len(msd)</span></code>. If there are values bigger than that, raises a
<code class="xref any docutils literal notranslate"><span class="pre">ValueError</span></code>. If not specified, will default to 100 trajectories of
maximum length.</p></li>
<li><p><strong>d</strong> (<em>int</em><em>, </em><em>optional</em>) – spatial dimension of the trajectories to sample</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="tracklib.html#tracklib.taggedset.TaggedSet" title="tracklib.taggedset.TaggedSet"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TaggedSet</span></code></a> of <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> – the generated data set.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.models.statgauss.sampleMSD" title="tracklib.models.statgauss.sampleMSD"><code class="xref py py-func docutils literal notranslate"><span class="pre">sampleMSD()</span></code></a>, <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref py py-func docutils literal notranslate"><span class="pre">tracklib.trajectory.Trajectory()</span></code></a>, <a class="reference internal" href="tracklib.html#tracklib.taggedset.TaggedSet" title="tracklib.taggedset.TaggedSet"><code class="xref py py-func docutils literal notranslate"><span class="pre">tracklib.taggedset.TaggedSet()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The input MSD is assumed to be the goal for the generated trajectories,
i.e. incorporate the prefactor <code class="docutils literal notranslate"><span class="pre">N*d</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.models.statgauss.control">
<code class="sig-prename descclassname">tracklib.models.statgauss.</code><code class="sig-name descname">control</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">msd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.models.statgauss.control" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a stationary control data set to the one given.</p>
<p>The control will look exactly like the original in all “meta”-aspects
(number of trajectories, their length, any meta data, etc.), but the
trajectories will be sampled from a stationary Gaussian process with the
given MSD (or the empirical ensemble MSD of the original).</p>
<p>The mean of each trajectory will be set to coincide with the mean of the
sister trajectory it is generated from.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<a class="reference internal" href="tracklib.html#tracklib.taggedset.TaggedSet" title="tracklib.taggedset.TaggedSet"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TaggedSet</span></code></a> of <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>) – the dataset to generate a control for</p></li>
<li><p><strong>msd</strong> (<em>(</em><em>T</em><em>,</em><em>) </em><em>np.ndarray</em><em>, </em><em>callable</em><em>, or </em><em>None</em>) – the MSD to use for sampling, either directly (i.e. as array) or as
function that will be evaluated on the needed lag times (where the unit
of time is one frame). Note that this will be divided by
(#loci)x(#dimensions) before sampling scalar traces, matching the usual
notion of MSD of (e.g.) multidimensional trajectories.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="tracklib.html#tracklib.taggedset.TaggedSet" title="tracklib.taggedset.TaggedSet"><code class="xref any py py-class docutils literal notranslate"><span class="pre">TaggedSet</span></code></a> of <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> – the generated control data set.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Generation from empirical MSDs does not always work, since they might be
noisy. In that case, provide a smoothed version as <code class="xref any docutils literal notranslate"><span class="pre">msd</span></code>.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">tracklib.models</a><ul>
<li><a class="reference internal" href="#module-tracklib.models.rouse">tracklib.models.rouse</a></li>
<li><a class="reference internal" href="#module-tracklib.models.statgauss">tracklib.models.statgauss</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tracklib.io.html"
                        title="previous chapter">tracklib.io</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tracklib.util.html"
                        title="next chapter">tracklib.util</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tracklib.models.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tracklib.util.html" title="tracklib.util"
             >next</a> |</li>
        <li class="right" >
          <a href="tracklib.io.html" title="tracklib.io"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">tracklib 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tracklib.html" >tracklib</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Simon Grosse-Holz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>