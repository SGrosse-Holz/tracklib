
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tracklib.analysis package &#8212; tracklib 0.1 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">tracklib 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tracklib-analysis-package">
<h1>tracklib.analysis package<a class="headerlink" href="#tracklib-analysis-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-tracklib.analysis.chi2">
<span id="tracklib-analysis-chi2-module"></span><h2>tracklib.analysis.chi2 module<a class="headerlink" href="#module-tracklib.analysis.chi2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="tracklib.analysis.chi2.chi2vsMSD">
<code class="sig-prename descclassname">tracklib.analysis.chi2.</code><code class="sig-name descname">chi2vsMSD</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">n=10</em>, <em class="sig-param">msd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.chi2.chi2vsMSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the snippet-wise chi-square score for trajectories vs. a given
MSD. This can be used to check for statistical homogeneity, within single
trajectories and across the dataset.</p>
<dl class="simple">
<dt>dataset<span class="classifier">TaggedSet of Trajectory</span></dt><dd><p>the trajectories to use</p>
</dd>
<dt>n<span class="classifier">integer</span></dt><dd><p>the window size / length of the snippets to look at</p>
</dd>
<dt>msd<span class="classifier">array-like, longer than n</span></dt><dd><p>the MSD to use for defining the reference Gaussian process. If omitted,
this will be the empirical MSD of the data, as given by MSD(dataset).
Note: we assume that this MSD is for trajectories like the one in the
dataset, i.e. if you want to specify diffusive motion in d-dimensions,
use 2*d*D*t, not 2*D*t.</p>
</dd>
</dl>
<p>The calculated chi-square scores will be written to the trajectory metadata
as ‘chi2scores’.
This function returns the #dof for the reference chi2 distribution (for use
with scipy.stats.chi2)</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.chi2.summary_plot">
<code class="sig-prename descclassname">tracklib.analysis.chi2.</code><code class="sig-name descname">summary_plot</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">dof=None</em>, <em class="sig-param">p=0.05</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.chi2.summary_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Histogram the chi-square scores calculated with chi2vsMSD(). This assumes
that each trajectory has a metadata field ‘chi2scores’. Optionally also
plots significance thresholds and/or the expected chi2 distribution.</p>
<dl class="simple">
<dt>dataset<span class="classifier">TaggedSet of Trajectory</span></dt><dd><p>the data to use</p>
</dd>
<dt>dof<span class="classifier">integer</span></dt><dd><p>degrees of freedom for the reference chi2 distribution. If omitted, no
reference will be shown.</p>
</dd>
<dt>p<span class="classifier">float in (0, 1)</span></dt><dd><p>significance level at which to draw cutoffs. Can be set to None to
prevent the plotting of these lines.
default: 0.05</p>
</dd>
<dt>ax<span class="classifier">the axes handle into which to plot.</span></dt><dd><p>default: plt.gca()</p>
</dd>
</dl>
<p>Additional kwargs will be forwarded to plt.hist() for plotting</p>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.kld">
<span id="tracklib-analysis-kld-module"></span><h2>tracklib.analysis.kld module<a class="headerlink" href="#module-tracklib.analysis.kld" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="tracklib.analysis.kld.KLD_PC">
<code class="sig-prename descclassname">tracklib.analysis.kld.</code><code class="sig-name descname">KLD_PC</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">n=10</em>, <em class="sig-param">k=20</em>, <em class="sig-param">dt=1</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kld.KLD_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the KLD estimator presented by (Perez-Cruz, 2008). We reduce the
bias of the estimator by randomly choosing half the snippets for
estimation of the densities and then sample at the other half.</p>
<dl class="simple">
<dt>dataset<span class="classifier">TaggedSet of Trajectory</span></dt><dd><p>the data to run the KLD estimation on</p>
</dd>
<dt>n<span class="classifier">integer</span></dt><dd><p>snippet length ( = window size)
default: 10</p>
</dd>
<dt>k<span class="classifier">integer</span></dt><dd><p>order of nearest neighbor for the estimator
default: 20</p>
</dd>
<dt>dt<span class="classifier">integer</span></dt><dd><p>number of frames between two data points in a snippet.
default: 1</p>
</dd>
</dl>
<p>Dest : estimated KLD in nats</p>
<p class="rubric">Notes</p>
<p>This function flattens snippets, i.e. if the trajectory has 2 loci and 3
dimensions, the KLD estimation will be run in 6n-dimensional space. Since
this might not be the desired behavior, the user might have to do some
pre-processing.
For more advanced use, refer to class KLDestimator.</p>
</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.kld.Estimator">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.kld.</code><code class="sig-name descname">Estimator</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kld.Estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A wrapper class for KLD estimation. Facilitates pre-processing,
bootstrapping and (eventually) use of different estimators.</p>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>There are two ways of applying pre-processing to the data:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>either do the preprocessing upon initialization:</dt><dd><p>est = KLDestimator(dataset.process(&lt;preproc&gt;), copy=False)</p>
</dd>
</dl>
</li>
<li><p>or preprocess in an individual step, using the preprocess function.</p></li>
</ul>
</dd>
</dl>
<p>As shown in the example, if preprocessing upon initialization, one can set
the ‘copy’ argument to False to avoid unnecessary copying.</p>
<p>For repeated evaluation on different parts of the same dataset: make sure
to reset the selection in the dataset with a call to
dataset.makeSelection() before initialization/preprocessing, such that all
data will undergo preprocessing. Then you can subsequently call
KLDestimator.dataset.makeSelection() to select parts of your dataset for
estimation.</p>
<dl class="method">
<dt id="tracklib.analysis.kld.Estimator.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kld.Estimator.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the environment/parameters for running the estimation.</p>
<dl class="simple">
<dt>KLDmethod<span class="classifier">callable</span></dt><dd><p>the method to use for KLD estimation.
default: KLD_PC</p>
</dd>
<dt>bootstraprepeats<span class="classifier">integer</span></dt><dd><p>how often to repeat each run with a different partition of the data
set.
default: 20</p>
</dd>
<dt>processes<span class="classifier">integer</span></dt><dd><p>how many processes to use.
default: 16</p>
</dd>
<dt>other keyword arguments :</dt><dd><p>the parameters for the estimation method. Anything given as a list
will be sweeped.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The default values for everything are set in __init__(), so you can
call this method also to change specific values while keeping
everything else the same.</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kld.Estimator.preprocess">
<code class="sig-name descname">preprocess</code><span class="sig-paren">(</span><em class="sig-param">preproc</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kld.Estimator.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Run some preprocessing on the data set.</p>
<dl>
<dt>preproc<span class="classifier">callable, taking a trajectory and returning a trajectory</span></dt><dd><p>the function to use for preprocessing. Will be applied to every
trajectory individually via TaggedSet.apply().
Examples:</p>
<blockquote>
<div><p>lambda traj : traj.relative().abs() # would give absolute distance for two-locus trajectory
lambda traj : traj.relative().diff().abs() # would give absolute displacements</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If writing your own preproc function (i.e. not using the ones from
Trajectory) remember to update the parity property of all trajectories.</p>
<p>As of now, this function literally only calls self.dataset.apply(preproc).
It serves more as a reminder that preprocessing might be necessary.</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kld.Estimator.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kld.Estimator.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the estimation. Remember to setup() and possibly preprocess().</p>
<p>A dict of argument lists and a corresponding np.ndarray for the
computed KLDs.</p>
<p class="rubric">Notes</p>
<p>For reproducible results, set random.seed() before calling this function</p>
<p>As of now, the data is copied to every child process. Maybe this could
be improved</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.kli">
<span id="tracklib-analysis-kli-module"></span><h2>tracklib.analysis.kli module<a class="headerlink" href="#module-tracklib.analysis.kli" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="tracklib.analysis.kli.LoopSequence">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.kli.</code><code class="sig-name descname">LoopSequence</code><span class="sig-paren">(</span><em class="sig-param">T</em>, <em class="sig-param">numInt</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represent a sequence of looping intervals</p>
<p>Attributes:
t : (n-1,) float-array</p>
<blockquote>
<div><p>the boundaries of a loop/no-loop region
the region t[i]—t[i+1] contains all trajectory indices ind with</p>
<blockquote>
<div><p>t[i]-0.5 &lt;= ind &lt; t[i+1]-0.5</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>isLoop<span class="classifier">(n,) bool-array</span></dt><dd><p>isLoop[i] tells us whether the interval ending at t[i] has a loop</p>
</dd>
</dl>
<dl class="method">
<dt id="tracklib.analysis.kli.LoopSequence.toLooptrace">
<code class="sig-name descname">toLooptrace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequence.toLooptrace" title="Permalink to this definition">¶</a></dt>
<dd><p>give a list of True/False for each time point</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kli.LoopSequence.fromLooptrace">
<em class="property">classmethod </em><code class="sig-name descname">fromLooptrace</code><span class="sig-paren">(</span><em class="sig-param">looptrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequence.fromLooptrace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kli.LoopSequence.numLoops">
<code class="sig-name descname">numLoops</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequence.numLoops" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kli.LoopSequence.plottable">
<code class="sig-name descname">plottable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequence.plottable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return t, loop for plotting</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.kli.LoopSequenceMCMC">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.kli.</code><code class="sig-name descname">LoopSequenceMCMC</code><a class="headerlink" href="#tracklib.analysis.kli.LoopSequenceMCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p>
<p>Here we will use LoopSequence objects as parameters</p>
<dl class="method">
<dt id="tracklib.analysis.kli.LoopSequenceMCMC.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequenceMCMC.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the data for loop estimation</p>
<dl class="simple">
<dt>traj<span class="classifier">Trajectory</span></dt><dd><p>the trajectory to run on</p>
</dd>
<dt>model<span class="classifier">tracklib.models.rouse.Model</span></dt><dd><p>the model to use</p>
</dd>
</dl>
<p>Remaining kwargs go to tracklib.models.rouse.likelihood()</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kli.LoopSequenceMCMC.propose_update">
<code class="sig-name descname">propose_update</code><span class="sig-paren">(</span><em class="sig-param">current_sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequenceMCMC.propose_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Propose an update</p>
<p>proposed_values : array of proposed values
p_forward : probability of proposing these values from the current ones
p_backward : probability of proposing the current values from the proposed ones</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kli.LoopSequenceMCMC.logL">
<code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequenceMCMC.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the log-likelihood of the given set of parameters</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kli.LoopSequenceMCMC.callback_logging">
<code class="sig-name descname">callback_logging</code><span class="sig-paren">(</span><em class="sig-param">current_sequence</em>, <em class="sig-param">best_sequence</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopSequenceMCMC.callback_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback upon logging</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.kli.LoopTraceMCMC">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.kli.</code><code class="sig-name descname">LoopTraceMCMC</code><a class="headerlink" href="#tracklib.analysis.kli.LoopTraceMCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.kli.LoopSequenceMCMC" title="tracklib.analysis.kli.LoopSequenceMCMC"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.kli.LoopSequenceMCMC</span></code></a></p>
<p>Run MCMC directly on the loop trace.</p>
<dl class="method">
<dt id="tracklib.analysis.kli.LoopTraceMCMC.propose_update">
<code class="sig-name descname">propose_update</code><span class="sig-paren">(</span><em class="sig-param">current_looptrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopTraceMCMC.propose_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Propose an update</p>
<p>proposed_values : array of proposed values
p_forward : probability of proposing these values from the current ones
p_backward : probability of proposing the current values from the proposed ones</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.kli.LoopTraceMCMC.logL">
<code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">looptrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.kli.LoopTraceMCMC.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the log-likelihood of the given set of parameters</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.msd">
<span id="tracklib-analysis-msd-module"></span><h2>tracklib.analysis.msd module<a class="headerlink" href="#module-tracklib.analysis.msd" title="Permalink to this headline">¶</a></h2>
<p>Everything to do with MSDs and calculating them.</p>
<p>Apart from immediately returning the most relevant results, the functions in
this module also store data in the Trajectory.meta dict. The fully populated
structure looks as follows (for a Trajectory traj):</p>
<dl>
<dt>traj.meta[‘MSD’]<span class="classifier">np.ndarray</span></dt><dd><p>the actual MSD of the trajectory</p>
</dd>
<dt>traj.meta[‘MSDmeta’]<span class="classifier">dict</span></dt><dd><p>some meta data for the MSD. Contains the following fields:
‘N’ : np.ndarray</p>
<blockquote>
<div><p>the number of sample points for each point of the MSD</p>
</div></blockquote>
<dl class="simple">
<dt>‘alpha’<span class="classifier">float</span></dt><dd><p>the fitted powerlaw exponent at the beginning of the MSD</p>
</dd>
<dt>‘logG’<span class="classifier">float</span></dt><dd><p>logarithm of the prefactor from the same fit as ‘alpha’</p>
</dd>
<dt>‘fit_covariance’<span class="classifier">(2, 2) np.ndarray</span></dt><dd><p>covariance matrix of (alpha, logG) from the fit</p>
</dd>
</dl>
</dd>
</dl>
<dl class="function">
<dt id="tracklib.analysis.msd.MSDtraj">
<code class="sig-prename descclassname">tracklib.analysis.msd.</code><code class="sig-name descname">MSDtraj</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.msd.MSDtraj" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate/give MSD for a single trajectory.</p>
<p>The result of the MSD calculation is stored in traj.meta[‘MSD’] and
traj.meta[‘MSDmeta’]. This function checks whether the corresponding fields
exist and if not calculates them, in any case returning their entries at
the end. So you can either use the return value of this function for
further processing, or access the corresponding fields in traj.meta.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>traj</strong> (<em>tracklib.Trajectory</em>) – the trajectory for which to calculate the MSD</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>MSD</strong> (<em>np.ndarray</em>) – the MSD of the trajectory, where MSD[0] = 0, MSD[1] is lag time of 1
frame, etc.</p></li>
<li><p><em>Writes</em></p></li>
<li><p><em>——</em></p></li>
<li><p><em>traj.meta[‘MSD’]</em> – the MSD that is also returned by the function</p></li>
<li><p><em>traj.meta[‘MSDmeta’][‘N’]</em> – for each data point in the MSD, how many points it is averaged over.
This is mostly important for correct calculation of ensemble means.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function expects a single-locus trajectory (N=1) and will raise a
ValueError otherwise. Preprocess accordingly.</p>
<p>Usually this function should always be preferred to accessing
traj.meta[‘MSD’] directly.</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.msd.MSDdataset">
<code class="sig-prename descclassname">tracklib.analysis.msd.</code><code class="sig-name descname">MSDdataset</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">giveN=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.msd.MSDdataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate ensemble MSD for the given dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<a class="reference internal" href="tracklib.html#tracklib.taggedset.TaggedSet" title="tracklib.taggedset.TaggedSet"><em>TaggedSet</em></a>) – a list of Trajectory for which to calculate an ensemble MSD</p></li>
<li><p><strong>giveN</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to return the sample size for each MSD data point</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>msd / (msd, N)</strong> (np.ndarray / tuple of np.ndarray, see <cite>giveN</cite>) – either just the enseble MSD or the MSD and the number of samples for
each data point</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Corresponding to python’s 0-based indexing, msd[0] = 0, such that
msd[dt] is the MSD at a time lag of dt frames.</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.msd.MSD">
<code class="sig-prename descclassname">tracklib.analysis.msd.</code><code class="sig-name descname">MSD</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.msd.MSD" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut function to calculate MSDs.</p>
<p>Will select either MSDtraj or MSDdataset, depending on the type of the
first argument. Everything is then forwarded to the appropriate function.</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.msd.scaling">
<code class="sig-prename descclassname">tracklib.analysis.msd.</code><code class="sig-name descname">scaling</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.msd.scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a powerlaw scaling to the first n data points of the MSD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – the trajectory whose MSD we are interested in</p></li>
<li><p><strong>n</strong> (<em>int</em><em>, </em><em>optional</em>) – how many data points of the MSD to use for fitting</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em>) – the fitted powerlaw scaling. For more details refer to
traj.meta[‘MSDmeta’]</p></li>
<li><p><em>Writes</em></p></li>
<li><p><em>——</em></p></li>
<li><p><strong>traj.meta[‘MSDmeta’][‘alpha’]</strong> (<em>float</em>) – same as return value</p></li>
<li><p><strong>traj.meta[‘MSDmeta’][‘logG’]</strong> (<em>float</em>) – logarithm of the MSD prefactor</p></li>
<li><p><strong>traj.meta[‘MSDmeta’][‘fit_covariance’]</strong> (<em>(2, 2) np.ndarray</em>) – covariance matrix of (alpha, logG) from the fit</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>logG is known to be a bad estimator for diffusivities.</p>
<p>“first n points of the MSD” means time lags 1 through n.</p>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.plots">
<span id="tracklib-analysis-plots-module"></span><h2>tracklib.analysis.plots module<a class="headerlink" href="#module-tracklib.analysis.plots" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="tracklib.analysis.plots.length_distribution">
<code class="sig-prename descclassname">tracklib.analysis.plots.</code><code class="sig-name descname">length_distribution</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.plots.length_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a histogram of trajectory lengths for the given dataset</p>
<dl class="simple">
<dt>dataset<span class="classifier">TaggedSet (possibly with some selection set)</span></dt><dd><p>the dataset to use</p>
</dd>
</dl>
<p>All other keyword arguments will be forwarded to plt.hist().</p>
<p>The return value of plt.hist(), i.e. a tuple (n, bins, patches)</p>
<p class="rubric">Notes</p>
<p>This should be thought of only as a quickshot way to take a look at the
data. For more elaborate plotting, obtain the trajectory lengths as</p>
<blockquote>
<div><p>lengths = [len(traj) for traj in dataset]</p>
</div></blockquote>
<p>and produce a plot to your liking.</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.plots.msd_overview">
<code class="sig-prename descclassname">tracklib.analysis.plots.</code><code class="sig-name descname">msd_overview</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.plots.msd_overview" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot individual and ensemble MSDs of the given dataset</p>
<dl class="simple">
<dt>dataset<span class="classifier">TaggedSet (possibly with some selection set)</span></dt><dd><p>the dataset to use</p>
</dd>
</dl>
<p>All further keyword arguments are forwarded to plt.loglog for plotting of
the individual trajectory MSDs</p>
<p>Aggregate of the plt.plot outputs, i.e. a list of lines</p>
<p class="rubric">Notes</p>
<p>Only intended as a quick overview plot, for more customization write your
own plotting routine using analysis.MSD(dataset) and Trajectory.msd().</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.plots.trajectories_spatial">
<code class="sig-prename descclassname">tracklib.analysis.plots.</code><code class="sig-name descname">trajectories_spatial</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.plots.trajectories_spatial" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the trajectories in the given dataset. The preset selection can be
overridden manually to ensure proper coloring (see Notes).</p>
<dl class="simple">
<dt>dataset<span class="classifier">TaggedSet</span></dt><dd><p>the set of trajectories to plot</p>
</dd>
<dt>colordict<span class="classifier">dict</span></dt><dd><p>determines which tag is colored in which color. This should be a dict
whose keys are the tags in the dataset, while the entries are anything
recognized by the ‘color’ kwarg of plt.plot.
default: cycle through the default color cycle</p>
</dd>
</dl>
<p>All further keyword arguments will be forwarded to
Trajectory.plot_spatial()</p>
<p>A list of lines, as returned by plt.plot()</p>
<p class="rubric">Notes</p>
<p>Each tag will be associated with one color, and trajectories will be
colored by one of the tags they’re associated with.  There is no way to
determine which one.</p>
<p>Similarly to the other analysis.plot_* and analysis.hist_* functions, this
is mostly intended for use in a quick overview. It does provide some more
functionality though, in the hope that the user will not see a necessity to
start plotting trajectories themselves.</p>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.plots.distance_distribution">
<code class="sig-prename descclassname">tracklib.analysis.plots.</code><code class="sig-name descname">distance_distribution</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.plots.distance_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram of distances. For two-locus trajectories, this is the
absolute distance between the loci, for single locus trajectories it is
simply the absolute value of the trajectory.</p>
<dl class="simple">
<dt>dataset<span class="classifier">TaggedSet (possibly with some selection set)</span></dt><dd><p>the trajectories to use</p>
</dd>
</dl>
<p>All keyword arguments will be forwarded to plt.hist()</p>
<p>The output of plt.hist(), i.e. a tuple (n, bins, patches).</p>
<p class="rubric">Notes</p>
<p>This is intended for gaining a quick overview. For more elaborate tasks,
obtain the distances as</p>
<blockquote>
<div><p>dists = np.concatenate([traj[:].flatten() for traj in dataset.process(&lt;preproc&gt;)])</p>
</div></blockquote>
<p>where &lt;preproc&gt; is the preprocessing function appropriate for your dataset.
For a two-locus trajectory, this would presumably be</p>
<blockquote>
<div><p>preproc = lambda traj : traj.relative().abs()</p>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-tracklib.analysis" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">tracklib.analysis package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.chi2">tracklib.analysis.chi2 module</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.kld">tracklib.analysis.kld module</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.kli">tracklib.analysis.kli module</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.msd">tracklib.analysis.msd module</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.plots">tracklib.analysis.plots module</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tracklib.analysis.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">tracklib 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Simon Grosse-Holz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>