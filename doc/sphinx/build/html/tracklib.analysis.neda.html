
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tracklib.analysis.neda &#8212; tracklib 0.1 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="tracklib.io" href="tracklib.io.html" />
    <link rel="prev" title="tracklib.analysis" href="tracklib.analysis.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tracklib.io.html" title="tracklib.io"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tracklib.analysis.html" title="tracklib.analysis"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">tracklib 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tracklib.html" >tracklib</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tracklib.analysis.html" accesskey="U">tracklib.analysis</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tracklib-analysis-neda">
<h1>tracklib.analysis.neda<a class="headerlink" href="#tracklib-analysis-neda" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.mcmc" id="id7">tracklib.analysis.neda.mcmc</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.models" id="id8">tracklib.analysis.neda.models</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.neda" id="id9">tracklib.analysis.neda.neda</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.plot" id="id10">tracklib.analysis.neda.plot</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.postproc" id="id11">tracklib.analysis.neda.postproc</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.priors" id="id12">tracklib.analysis.neda.priors</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.util" id="id13">tracklib.analysis.neda.util</a></p></li>
</ul>
</div>
<dl class="function">
<dt id="tracklib.analysis.neda.neda.main">
<code class="sig-prename descclassname">tracklib.analysis.neda.neda.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">priorfam</em>, <em class="sig-param">MCMCconfig</em>, <em class="sig-param">MCMCscheme=None</em>, <em class="sig-param">max_iterations=20</em>, <em class="sig-param">min_iterations=5</em>, <em class="sig-param">return_='nothing'</em>, <em class="sig-param">show_progress=False</em>, <em class="sig-param">assume_notebook_for_progressbar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the neda looping inference scheme</p>
<p>The output of the inference run will be assembled into a dict whose fields
are detailed below. Where exactly this dict will end up depends on the
setting of <code class="xref any docutils literal notranslate"><span class="pre">return_</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – the <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> whose looping profile to infer</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><em>models.Model</em></a>) – the inference model to use</p></li>
<li><p><strong>priorfam</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.ParametricFamily" title="tracklib.analysis.neda.util.ParametricFamily"><em>ParametricFamily</em></a>) – a family of priors</p></li>
<li><p><strong>MCMCconfig</strong> (<em>dict</em>) – configuration for the MCMC runs. See <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref any py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p></li>
<li><p><strong>MCMCscheme</strong> (<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><em>mcmc.MCMCScheme</em></a><em>, </em><em>optional</em>) – the sampling scheme to use, i.e. an object implementing the
<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><code class="xref any py py-class docutils literal notranslate"><span class="pre">mcmc.MCMCScheme</span></code></a> interface. Defaults to <a href="#id1"><span class="problematic" id="id2">`</span></a>mcmc.TPWMCMC’</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – maximum number of iterations to run</p></li>
<li><p><strong>min_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – run at least this many iterations</p></li>
<li><p><strong>return_</strong> (<em>{'nothing'</em><em>, </em><em>'None'</em><em>, </em><em>'traj'</em><em>, </em><em>'dict'}</em>) – what the return value of this function should be. Generally, the
results of the inference run will be stored in a dict. If
<code class="docutils literal notranslate"><span class="pre">return_='dict'</span></code>, that dict is directly returned. Otherwise it is
written to <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code>, and if <code class="docutils literal notranslate"><span class="pre">return_='traj'</span></code> the
trajectory is returned (useful for parallelization). Otherwise this
function returns nothing, i.e. the inference results can be accessed
simply from <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code> after calling this function.</p></li>
<li><p><strong>show_progress</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to show a progress bar. Note: for <code class="docutils literal notranslate"><span class="pre">show_progress=True</span></code> it
might happen that the termination condition is fulfilled during the
last “required” run, in which case the progress bar will stop before
reaching its maximum.</p></li>
<li><p><strong>assume_notebook_for_progressbar</strong> (<em>bool</em><em>, </em><em>optional</em>) – set to <code class="docutils literal notranslate"><span class="pre">False</span></code> if running outside Jupyter notebook to show
progressbar ASCII style</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>prior_prams</strong> (<em>np.array</em>) – the prior parameters for each iteration</p></li>
<li><p><strong>mcmcrun</strong> (<em>list of MCMCRun</em>) – the MCMC runs for each iteration</p></li>
<li><p><strong>evidence</strong> (<em>np.array</em>) – the evidence estimated from each <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p></li>
<li><p><strong>evidence_diff</strong> (<em>np.array</em>) – the estimated evidence differential (relative evidence) at each
iteration</p></li>
<li><p><strong>final</strong> (<em>dict</em>) – the corresponding values for the iteration that should be considered
the final result. Has entries <code class="docutils literal notranslate"><span class="pre">'prior_params'</span></code>, <code class="docutils literal notranslate"><span class="pre">'mcmcrun'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'evidence'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'iteration'</span></code> where the last one is the index of
the iteration the other three refer to.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Assuming we have a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> <code class="docutils literal notranslate"><span class="pre">traj</span></code> that we want to run the looping
inference on:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Set up inference scheme</span>
<span class="gp">... </span><span class="n">looppositions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># 2 states: unlooped (=0), fully looped (=1)</span>
<span class="gp">... </span><span class="n">model</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">RouseModel</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">k_extra</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">looppositions</span><span class="o">=</span><span class="n">looppositions</span><span class="p">)</span>
<span class="gp">... </span><span class="n">priorfam</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">ParametricFamily</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">... </span><span class="n">priorfam</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">logq</span> <span class="p">:</span> <span class="n">neda</span><span class="o">.</span><span class="n">priors</span><span class="o">.</span><span class="n">GeometricPrior</span><span class="p">(</span><span class="n">logq</span><span class="p">,</span> <span class="n">nStates</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">looppositions</span><span class="p">))</span>
<span class="gp">... </span><span class="n">MCMCconfig</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>        <span class="s1">&#39;iterations&#39;</span> <span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;burn_in&#39;</span>    <span class="p">:</span>  <span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">}</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Run the inference</span>
<span class="gp">... </span><span class="n">neda</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">priorfam</span><span class="p">,</span> <span class="n">MCMCconfig</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Visualize output</span>
<span class="gp">... </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="gp">... </span><span class="n">neda</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">butterfly</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
<span class="gp">... </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="tracklib.analysis.html#tracklib.analysis.kli.fit_RouseParams" title="tracklib.analysis.kli.fit_RouseParams"><code class="xref py py-func docutils literal notranslate"><span class="pre">tracklib.analysis.kli.fit_RouseParams()</span></code></a></p>
</div>
</dd></dl>

<div class="section" id="module-tracklib.analysis.neda.mcmc">
<span id="tracklib-analysis-neda-mcmc"></span><h2><a class="toc-backref" href="#id7">tracklib.analysis.neda.mcmc</a><a class="headerlink" href="#module-tracklib.analysis.neda.mcmc" title="Permalink to this headline">¶</a></h2>
<p>Formalizing the process of running <a class="reference internal" href="tracklib.util.html#module-tracklib.util.mcmc" title="tracklib.util.mcmc"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">util.mcmc</span></code></a></p>
<dl class="class">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.mcmc.</code><code class="sig-name descname">MCMCRun</code><span class="sig-paren">(</span><em class="sig-param">logLs=None</em>, <em class="sig-param">samples=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The results of an MCMC run</p>
<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.logLs">
<code class="sig-name descname">logLs</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.logLs" title="Permalink to this definition">¶</a></dt>
<dd><p>the likelihoods from the run</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.samples">
<code class="sig-name descname">samples</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>the actual MCMC sample</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of &lt;sample data type&gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.logLs_trunc">
<code class="sig-name descname">logLs_trunc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.logLs_trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Give only the likelihoods associated with the samples</p>
<p><a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler.run" title="tracklib.util.mcmc.Sampler.run"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler.run</span></code></a> returns likelihoods starting at the
first iteration, but samples only after a given burn-in period. This
function cuts this initial overhang from the likelihood array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>(len(samples),) np.ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.best_sample_L">
<code class="sig-name descname">best_sample_L</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.best_sample_L" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the best sample (and likelihood)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>sample</strong> (<em>&lt;sample data type&gt;</em>) – the maximum likelihood estimate</p></li>
<li><p><strong>logL</strong> (<em>float</em>) – the maximum likelihood value</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.acceptance_rate">
<code class="sig-name descname">acceptance_rate</code><span class="sig-paren">(</span><em class="sig-param">criterion='sample_identity'</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.acceptance_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate fraction of accepted moves</p>
<p>We can see whether a move was accepted or rejected by checking whether
the samples are actually different. There are three different ways to
do so: syntactically correct would be sample comparison (using <code class="docutils literal notranslate"><span class="pre">==</span></code>).
However, since samples have a user-defined data type, we do not
necessarily have the == operator defined. For mutable objects we can
exploit that they would not be copied for an unaccepted step, i.e. we
can use identity check (<code class="docutils literal notranslate"><span class="pre">is</span></code>). As a last resort, we can use the
likelihood as a proxy: it is very unlikeliy that we did a move where
the likelihood remained exactly the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>criterion</strong> (<em>{'sample_equality'</em><em>, </em><em>'sample_identity'</em><em>, </em><em>'likelihood_equality'}</em>) – which method to use to determine whether a step was accepted or
rejected.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the acceptance rate</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param">fun</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a function on all samples</p>
<p>This exploits that (if the sample data type is e.g. a user-defined
class) many samples will actually be identical and we have to evaluate
the function significantly fewer than <code class="docutils literal notranslate"><span class="pre">len(samples)</span></code> times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fun</strong> (callable of signature <code class="docutils literal notranslate"><span class="pre">fun(sample)</span> <span class="pre">--&gt;</span> <span class="pre">object</span></code>) – the function to evaluate. It should expect a single sample as input
and return something.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>list</em> – a list of output values, in the order of <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun.samples" title="tracklib.analysis.neda.mcmc.MCMCRun.samples"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">samples</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is supposed to decrease computational cost. It is usually
quicker however, to use a vectorized function <code class="docutils literal notranslate"><span class="pre">fun</span></code> instead.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.mcmc.</code><code class="sig-name descname">MCMCScheme</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p>
<p>Abstract base class for <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> MCMC schemes.</p>
<p>We might want to test different MCMC schemes, so this class intends to
reduce the overhead of introducing a new sampling scheme to a minimum. A
sampling scheme is given by its proposal distribution, so this is the
minimum information needed. This should be specified in two forms:
<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability" title="tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">stepping_probability</span></code></a> evaluates the actual proposal distribution, while
<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from" title="tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">gen_proposal_sample_from</span></code></a> should yield samples from the proposal
distribution. While <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.propose_update" title="tracklib.analysis.neda.mcmc.MCMCScheme.propose_update"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">propose_update</span></code></a> in principle can be assembled from
these (and is by default), it usually makes sense to implement this special
case separately, since it might save computational time (significantly).</p>
<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.traj">
<code class="sig-name descname">traj</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.traj" title="Permalink to this definition">¶</a></dt>
<dd><p>the trajectory we want to find <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtraces</span></code></a> for</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory">Trajectory</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.model">
<code class="sig-name descname">model</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.model" title="Permalink to this definition">¶</a></dt>
<dd><p>the inference model to use</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model">models.Model</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.prior">
<code class="sig-name descname">prior</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.prior" title="Permalink to this definition">¶</a></dt>
<dd><p>prior over <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Looingtraces</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior">priors.Prior</a></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<p>Assume we implemented some sampling scheme <code class="docutils literal notranslate"><span class="pre">MyScheme</span></code> and have <code class="docutils literal notranslate"><span class="pre">traj</span></code>,
<code class="docutils literal notranslate"><span class="pre">model</span></code>, and <code class="docutils literal notranslate"><span class="pre">prior</span></code> defined</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MCMCconfig</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;iterations&#39;</span> <span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;burn_in&#39;</span>    <span class="p">:</span>  <span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">}</span>
<span class="gp">... </span><span class="n">mcmc</span> <span class="o">=</span> <span class="n">MyScheme</span><span class="p">()</span>
<span class="gp">... </span><span class="n">mcmc</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">prior</span><span class="p">)</span>
<span class="gp">... </span><span class="n">mcmc</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="o">**</span><span class="n">MCMCconfig</span><span class="p">)</span>
<span class="gp">... </span><span class="n">res</span> <span class="o">=</span> <span class="n">mcmc</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up everything</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – the trajectory we want to find <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtraces</span></code></a> for</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><em>models.Model</em></a>) – the inference model to use</p></li>
<li><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>priors.Prior</em></a>) – prior over <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Looingtraces</span></code></a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the MCMC sampling and store results in an <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p>
<p>The <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.model" title="tracklib.analysis.neda.mcmc.MCMCScheme.model"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">model</span></code></a> will be queried for an initial <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>.</p>
<p>All arguments are forwarded to <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler.run" title="tracklib.util.mcmc.Sampler.run"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler.run</span></code></a>, which
at the time of writing does not take any more arguments than the
initial profile.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>MCMCRun</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.acceptance_probability">
<em class="property">static </em><code class="sig-name descname">acceptance_probability</code><span class="sig-paren">(</span><em class="sig-param">L_from</em>, <em class="sig-param">L_to</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.acceptance_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate acceptance probability from two likelihoods</p>
<p>This is given by <code class="docutils literal notranslate"><span class="pre">min(1,</span> <span class="pre">exp(L_to</span> <span class="pre">-</span> <span class="pre">L_from))</span></code>. This function exists
mostly for stylistic reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>L_to</strong> (<em>L_from</em><em>,</em>) – log-likelihoods of the states we are moving from and to</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.likelihood">
<em class="property">static </em><code class="sig-name descname">likelihood</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">loopingtrace</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the likelihood of the (loopingtrace, model, prior) combination</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><em>models.Model</em></a>) – </p></li>
<li><p><strong>priors</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>priors.Prior</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.logL">
<code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate log-likelihood of the given parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the parameters to use</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the log-likelihood for the given parameters.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.propose_update" title="tracklib.analysis.neda.mcmc.MCMCScheme.propose_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propose_update()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">callback_logging()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability">
<em class="property">abstract </em><code class="sig-name descname">stepping_probability</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace_from</em>, <em class="sig-param">loopingtrace_to</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the proposal distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace_from</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the “current” <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
<li><p><strong>loopingtrace_to</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – another <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the probability that <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_to</span></code> was proposed, given that we
are currently at <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_from</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from" title="tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gen_proposal_sample_from()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from">
<em class="property">abstract </em><code class="sig-name descname">gen_proposal_sample_from</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">nSample=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from the proposal distribution</p>
<p>This function returns a generator yielding <code class="xref any docutils literal notranslate"><span class="pre">nSample</span></code> samples from the
proposal distribution around <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>nSample</strong> (<em>float</em><em>, </em><em>optional</em>) – how many samples to draw. The default value <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code>
indicates exhaustive sampling of the distribution</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>Loopingtrace</em> – samples from the proposal distribution</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability" title="tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stepping_probability()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.propose_update">
<code class="sig-name descname">propose_update</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace_cur</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.propose_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Propose an update step.</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">self.stepsize</span></code> for the proposal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the current parameters</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>proposed_values</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the proposed new parameters</p></li>
<li><p><strong>logp_forward</strong> (<em>float</em>) – (log of the) probability of proposing these values from the current
ones</p></li>
<li><p><strong>logp_backward</strong> (<em>float</em>) – (log of the) probability of proposing the current values from the
proposed ones</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.logL" title="tracklib.analysis.neda.mcmc.MCMCScheme.logL"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logL()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">callback_logging()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.mcmc.TPWMCMC">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.mcmc.</code><code class="sig-name descname">TPWMCMC</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TPWMCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.mcmc.MCMCScheme</span></code></a></p>
<p>A time-point wise sampling scheme</p>
<p>Probably the most straight-forward sampling scheme. At each step, randomly
assign a new state for a single random frame.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.TPWMCMC.stepping_probability">
<code class="sig-name descname">stepping_probability</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace_from</em>, <em class="sig-param">loopingtrace_to</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TPWMCMC.stepping_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the proposal distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace_from</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the “current” <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
<li><p><strong>loopingtrace_to</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – another <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the probability that <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_to</span></code> was proposed, given that we
are currently at <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_from</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.TPWMCMC.gen_proposal_sample_from" title="tracklib.analysis.neda.mcmc.TPWMCMC.gen_proposal_sample_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gen_proposal_sample_from()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.TPWMCMC.gen_proposal_sample_from">
<code class="sig-name descname">gen_proposal_sample_from</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">nSample=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TPWMCMC.gen_proposal_sample_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from the proposal distribution</p>
<p>This function returns a generator yielding <code class="xref any docutils literal notranslate"><span class="pre">nSample</span></code> samples from the
proposal distribution around <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>nSample</strong> (<em>float</em><em>, </em><em>optional</em>) – how many samples to draw. The default value <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code>
indicates exhaustive sampling of the distribution</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>Loopingtrace</em> – samples from the proposal distribution</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.TPWMCMC.stepping_probability" title="tracklib.analysis.neda.mcmc.TPWMCMC.stepping_probability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stepping_probability()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.TPWMCMC.propose_update">
<code class="sig-name descname">propose_update</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace_cur</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TPWMCMC.propose_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Propose an update step.</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">self.stepsize</span></code> for the proposal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the current parameters</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>proposed_values</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the proposed new parameters</p></li>
<li><p><strong>logp_forward</strong> (<em>float</em>) – (log of the) probability of proposing these values from the current
ones</p></li>
<li><p><strong>logp_backward</strong> (<em>float</em>) – (log of the) probability of proposing the current values from the
proposed ones</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logL()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">callback_logging()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.mcmc.TriMCMC">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.mcmc.</code><code class="sig-name descname">TriMCMC</code><span class="sig-paren">(</span><em class="sig-param">weights=(1</em>, <em class="sig-param">1</em>, <em class="sig-param">1)</em>, <em class="sig-param">alpha=1</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TriMCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.mcmc.MCMCScheme</span></code></a></p>
<p>An interval oriented sampling scheme</p>
<p>For each proposal select one interval in the current trace and change some
part of it. We use three different moves:</p>
<blockquote>
<div><ul>
<li><p>cluster flip : choose a new value for the whole interval</p></li>
<li><dl class="simple">
<dt>boundary move<span class="classifier">move one of the interval boundaries. How far the move</span></dt><dd><p>goes is governed by a power law</p>
</dd>
</dl>
</li>
<li><dl>
<dt>uniform triangular<span class="classifier">select a random sub-interval <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b)</span></code> to change.</span></dt><dd><p>The tuple <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> comes from a uniform distribution over the
triangle <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;=</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the length of the current
interval.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The probabilities for the different moves are governed by the weights
handed to the initializer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>array-like</em><em>, </em><em>optional</em>) – the weights with which to choose the different moves. Order is
<code class="docutils literal notranslate"><span class="pre">(cluster</span> <span class="pre">flip,</span> <span class="pre">boundary</span> <span class="pre">move,</span> <span class="pre">uniform</span> <span class="pre">triangular)</span></code>.  Note that the
triangular sampling in principle also includes the other two moves.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em>) – the exponent in the power law for boundary moves. We recommend <code class="docutils literal notranslate"><span class="pre">alpha</span>
<span class="pre">&gt;</span> <span class="pre">1</span></code> such that most moves are short.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.TriMCMC.stepping_probability">
<code class="sig-name descname">stepping_probability</code><span class="sig-paren">(</span><em class="sig-param">lt_from</em>, <em class="sig-param">lt_to</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TriMCMC.stepping_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the proposal distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace_from</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the “current” <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
<li><p><strong>loopingtrace_to</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – another <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the probability that <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_to</span></code> was proposed, given that we
are currently at <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_from</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.TriMCMC.gen_proposal_sample_from" title="tracklib.analysis.neda.mcmc.TriMCMC.gen_proposal_sample_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gen_proposal_sample_from()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.TriMCMC.gen_proposal_sample_from">
<code class="sig-name descname">gen_proposal_sample_from</code><span class="sig-paren">(</span><em class="sig-param">lt</em>, <em class="sig-param">nSample=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TriMCMC.gen_proposal_sample_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from the proposal distribution</p>
<p>This function returns a generator yielding <code class="xref any docutils literal notranslate"><span class="pre">nSample</span></code> samples from the
proposal distribution around <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>nSample</strong> (<em>float</em><em>, </em><em>optional</em>) – how many samples to draw. The default value <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code>
indicates exhaustive sampling of the distribution</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>Loopingtrace</em> – samples from the proposal distribution</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.TriMCMC.stepping_probability" title="tracklib.analysis.neda.mcmc.TriMCMC.stepping_probability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stepping_probability()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.models">
<span id="tracklib-analysis-neda-models"></span><h2><a class="toc-backref" href="#id8">tracklib.analysis.neda.models</a><a class="headerlink" href="#module-tracklib.analysis.neda.models" title="Permalink to this headline">¶</a></h2>
<p>The inference models, and the interface they have to conform to.</p>
<dl class="class">
<dt id="tracklib.analysis.neda.models.Model">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.models.</code><code class="sig-name descname">Model</code><a class="headerlink" href="#tracklib.analysis.neda.models.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class for inference models</p>
<p>The most important capability of any model is the likelihood function
<a class="reference internal" href="#tracklib.analysis.neda.models.Model.logL" title="tracklib.analysis.neda.models.Model.logL"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logL</span></code></a> for a combination of <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> and <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>. Furthermore, a
model should provide an initial guess for a good <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>.</p>
<p>The method <a class="reference internal" href="#tracklib.analysis.neda.models.Model.trajectory_from_loopingtrace" title="tracklib.analysis.neda.models.Model.trajectory_from_loopingtrace"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">trajectory_from_loopingtrace</span></code></a> is considered an optional part of
the interface, since it is not important to the inference, but might come
in handy when working with a <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>. So it is recommended but not
required.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.models.Model.initial_loopingtrace">
<em class="property">abstract </em><code class="sig-name descname">initial_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.Model.initial_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a quick guess for a good <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> for a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.Model.logL">
<em class="property">abstract </em><code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.Model.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (log-)likelihood for (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>) pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – log-likelihood associated with the inputs</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.Model.trajectory_from_loopingtrace">
<code class="sig-name descname">trajectory_from_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">localization_error=0.1</em>, <em class="sig-param">d=3</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.Model.trajectory_from_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> from this <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> and the given <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>localization_error</strong> (<em>float</em><em>, </em><em>optional</em>) – how much Gaussian noise to add to the trajectory.</p></li>
<li><p><strong>d</strong> (<em>int</em><em>, </em><em>optional</em>) – number of spatial dimensions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Trajectory</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.models.RouseModel">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.models.</code><code class="sig-name descname">RouseModel</code><span class="sig-paren">(</span><em class="sig-param">N, D, k, looppositions=[(0, 0), (0, -1)], k_extra=None, measurement='end2end'</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.models.Model</span></code></a></p>
<p>Inference with Rouse models</p>
<p>This inference model uses a given number of <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></a> instances to
choose from for each propagation interval. In the default use case this
switches between a looped and unlooped model, but it could be way more
general than that, e.g. incorporating different looped states, loop
positions, numbers of loop, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>D</strong><strong>, </strong><strong>k</strong> (<em>N</em><em>,</em>) – parameters for the <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></a>. <code class="xref any docutils literal notranslate"><span class="pre">N</span></code> is the number of monomers, <code class="xref any docutils literal notranslate"><span class="pre">D</span></code>
the diffusion constant of a free monomer, <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model.k" title="tracklib.models.rouse.Model.k"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">k</span></code></a> the backbone strength.</p></li>
<li><p><strong>looppositions</strong> (<em>list of 2-tuples of int</em><em>, </em><em>optional</em>) – list of positions of the extra bond. For each entry, a new
<a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></a> instance will be set up. Remember to include an unlooped
model (if wanted) by including a position like <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>.</p></li>
<li><p><strong>k_extra</strong> (<em>float</em><em>, </em><em>optional</em>) – the strength of the extra bond. By default equal to <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model.k" title="tracklib.models.rouse.Model.k"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">k</span></code></a></p></li>
<li><p><strong>measurement</strong> (<em>&quot;end2end&quot;</em><em> or </em><em>(</em><em>N</em><em>,</em><em>) </em><em>np.ndarray</em>) – which distance to measure. The default setting “end2end” is equivalent
to specifying a vector <code class="docutils literal notranslate"><span class="pre">np.array([-1,</span> <span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">0,</span> <span class="pre">1])</span></code>, i.e. measuring
the distance from the first to the last monomer.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.models.RouseModel.models">
<code class="sig-name descname">models</code><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel.models" title="Permalink to this definition">¶</a></dt>
<dd><p>the models used for inference</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></a></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>By default, this model assumes that the difference between the models is
the position of the extra bond. It is easy to generalize this, by editing
the <a class="reference internal" href="#tracklib.analysis.neda.models.RouseModel.models" title="tracklib.analysis.neda.models.RouseModel.models"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">models</span></code></a> attribute after initialization. The only thing to pay
attention to is that each model needs to have a <code class="xref any docutils literal notranslate"><span class="pre">measurement</span></code> vector.</p>
<p>The <a class="reference internal" href="#tracklib.analysis.neda.models.RouseModel.initial_loopingtrace" title="tracklib.analysis.neda.models.RouseModel.initial_loopingtrace"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">initial_loopingtrace</span></code></a> for this <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> is the MLE assuming time scale
separation. I.e. we calculate the timepoint-wise MLE using the exact steady
state distributions of each model.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></p>
</div>
<dl class="method">
<dt id="tracklib.analysis.neda.models.RouseModel.initial_loopingtrace">
<code class="sig-name descname">initial_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel.initial_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a quick guess for a good <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> for a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.RouseModel.logL">
<code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (log-)likelihood for (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>) pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – log-likelihood associated with the inputs</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.RouseModel.trajectory_from_loopingtrace">
<code class="sig-name descname">trajectory_from_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">localization_error=0.1</em>, <em class="sig-param">d=3</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel.trajectory_from_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> from this <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> and the given <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>localization_error</strong> (<em>float</em><em>, </em><em>optional</em>) – how much Gaussian noise to add to the trajectory.</p></li>
<li><p><strong>d</strong> (<em>int</em><em>, </em><em>optional</em>) – number of spatial dimensions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Trajectory</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.models.FactorizedModel">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.models.</code><code class="sig-name descname">FactorizedModel</code><span class="sig-paren">(</span><em class="sig-param">distributions</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.models.Model</span></code></a></p>
<p>A simplified model, assuming time scale separation</p>
<p>This model assumes that each point is sampled from one of a given list of
distributions, where there is no correlation between the choice of
distribution for each point. It runs significantly faster than the full
<a class="reference internal" href="#tracklib.analysis.neda.models.RouseModel" title="tracklib.analysis.neda.models.RouseModel"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RouseModel</span></code></a>, but is of course inaccurate if the Rouse time is longer or
comparable to the frame rate of the recorded trajectories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>distributions</strong> (<em>list of distribution objects</em>) – these will usually be <code class="docutils literal notranslate"><span class="pre">scipy.stats.rv_continuous</span></code> objects (e.g.
Maxwell), but can be pretty arbitrary. The only function they have to
provide is <code class="docutils literal notranslate"><span class="pre">logpdf()</span></code>, which should take a scalar or vector of
distance values and return a corresponding number of outputs. If you
plan on using <a class="reference internal" href="#tracklib.analysis.neda.models.FactorizedModel.trajectory_from_loopingtrace" title="tracklib.analysis.neda.models.FactorizedModel.trajectory_from_loopingtrace"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">trajectory_from_loopingtrace</span></code></a>, the distributions should
also have an <code class="docutils literal notranslate"><span class="pre">rvs()</span></code> method for sampling.</p>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.models.FactorizedModel.distributions">
<code class="sig-name descname">distributions</code><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.distributions" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of distribution objects</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This being a heuristical model, we assume that the localization error is
already incorporated in the <code class="xref any docutils literal notranslate"><span class="pre">distributions</span></code>, as would be the case if they
come from experimental data. Therefore, this class ignores the
<code class="docutils literal notranslate"><span class="pre">meta['localization_error']</span></code> field of <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>.</p>
<p>Instances of this class memoize trajectories they have seen before. To
reset the memoization, you can either reinstantiate or clear the cache
manually:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">FactorizedModel</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">distributions</span><span class="p">)</span>
<span class="gp">... </span><span class="n">model</span><span class="o">.</span><span class="n">clear_memo</span><span class="p">()</span>
</pre></div>
</div>
<p>If using <code class="docutils literal notranslate"><span class="pre">scipy.stats.maxwell</span></code>, make sure to use it correctly, i.e. you
have to specify <code class="docutils literal notranslate"><span class="pre">scale=...</span></code>. Writing <code class="docutils literal notranslate"><span class="pre">scipy.stats.maxwell(5)</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">scipy.stats.maxwell(scale=5)</span></code> shifts the distribution instead of
scaling it and leads to <code class="docutils literal notranslate"><span class="pre">-inf</span></code> values in the likelihood, which then screw
up the MCMC. The classic error to get for this is <code class="docutils literal notranslate"><span class="pre">invalid</span> <span class="pre">value</span>
<span class="pre">encountered</span> <span class="pre">in</span> <span class="pre">double_scalars</span></code>. This is caused by <code class="docutils literal notranslate"><span class="pre">new_logL</span> <span class="pre">-</span> <span class="pre">cur_logL</span></code>
reading <code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">inf</span> <span class="pre">+</span> <span class="pre">inf</span></code> at the first MCMC iteration, if <a class="reference internal" href="#tracklib.analysis.neda.models.FactorizedModel.logL" title="tracklib.analysis.neda.models.FactorizedModel.logL"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logL</span></code></a> returns
<code class="docutils literal notranslate"><span class="pre">-inf</span></code>.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.models.FactorizedModel.clear_memo">
<code class="sig-name descname">clear_memo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.clear_memo" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the memoization cache</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.FactorizedModel.initial_loopingtrace">
<code class="sig-name descname">initial_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.initial_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a quick guess for a good <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> for a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.FactorizedModel.logL">
<code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (log-)likelihood for (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>) pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – log-likelihood associated with the inputs</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.FactorizedModel.trajectory_from_loopingtrace">
<code class="sig-name descname">trajectory_from_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">localization_error=0.0</em>, <em class="sig-param">d=3</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.trajectory_from_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> from this <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> and the given <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>localization_error</strong> (<em>float</em><em>, </em><em>optional</em>) – how much Gaussian noise to add to the trajectory.</p></li>
<li><p><strong>d</strong> (<em>int</em><em>, </em><em>optional</em>) – number of spatial dimensions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Trajectory</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.neda.models.fit">
<code class="sig-prename descclassname">tracklib.analysis.neda.models.</code><code class="sig-name descname">fit</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">modelfamily</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the best fit model to a calibration dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>TaggedSet of Trajectory</em>) – the calibration data. Each <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> should have a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory.meta" title="tracklib.trajectory.Trajectory.meta"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">meta</span></code></a> entry <code class="docutils literal notranslate"><span class="pre">'loopingtrace'</span></code> indicating the true/assumed
<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> for this trajectory.</p></li>
<li><p><strong>modelfamily</strong> (<em>ParametricFamily of Models</em>) – the family of models to consider.</p></li>
<li><p><strong>kwargs</strong> (<em>kwargs</em>) – will be forwarded to <code class="xref any docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>. We use the defaults
<code class="docutils literal notranslate"><span class="pre">method='L-BFGS-B'</span></code>, <code class="docutils literal notranslate"><span class="pre">maxfun=300</span></code>, <code class="docutils literal notranslate"><span class="pre">ftol=1e-5</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> (<em>fitresult</em>) – the structure returned by <code class="xref any docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>. The best fit
parameters are <code class="docutils literal notranslate"><span class="pre">res.x</span></code>, while their covariance matrix can be obtained
as <code class="docutils literal notranslate"><span class="pre">res.hess_inv.todens()</span></code>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>A good measure for relative uncertainty of the estimate is given by
<code class="docutils literal notranslate"><span class="pre">(√det(Σ)</span> <span class="pre">/</span> <span class="pre">Π(x))^(1/n)</span></code>, i.e. the major axes of the covariance ellipsoid
over the point estimates, normalized by the dimensionality:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">modelfam</span><span class="p">)</span>
<span class="gp">... </span><span class="n">relative_uncertainty</span> <span class="o">=</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">hess_inv</span><span class="o">.</span><span class="n">todense</span><span class="p">()))</span>     <span class="o">...</span>                        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">modelfam</span><span class="o">.</span><span class="n">nParams</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ParametricFamily</p>
<dl class="simple">
<dt><strong>Troubleshooting</strong></dt><dd><ul class="simple">
<li><p>make sure that the magnitude of parameter values is around one. The
minimizer (see <code class="xref any docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>) defaults to a fixed step
gradient descent, which is useless if parameters are orders of magnitude
bigger than 1. You can also try to play with the minimizer’s options to
make it use an adaptive step size.</p></li>
<li><p>make sure units match up. A common mistake is to have a unit mismatch
between localization error and trajectories (e.g. one in μm and the
other in nm). If the localization error is too big (here by a factor of
1000), the fit for <code class="xref any docutils literal notranslate"><span class="pre">D</span></code> will converge to zero (i.e. <code class="docutils literal notranslate"><span class="pre">1e-10</span></code>).</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">'hess_inv'</span></code> field returned with <code class="docutils literal notranslate"><span class="pre">method='L-BFGS-B'</span></code> might not
be super reliable, even if the point estimate is pretty good. Check
initial conditions when using this.</p></li>
</ul>
</dd>
</dl>
</div>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.neda">
<span id="tracklib-analysis-neda-neda"></span><h2><a class="toc-backref" href="#id9">tracklib.analysis.neda.neda</a><a class="headerlink" href="#module-tracklib.analysis.neda.neda" title="Permalink to this headline">¶</a></h2>
<p>Main module of the neda inference package</p>
<p>This introduces the <a class="reference internal" href="#tracklib.analysis.neda.neda.Environment" title="tracklib.analysis.neda.neda.Environment"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Environment</span></code></a> class, which we use to facilitate repeating
tasks like running MCMC, calculating or estimating evidence. Finally, the
<a class="reference internal" href="#tracklib.analysis.neda.neda.main" title="tracklib.analysis.neda.neda.main"><code class="xref any py py-func docutils literal notranslate"><span class="pre">main</span></code></a> function runs the whole scheme. Note that both of these are imported
into the <code class="docutils literal notranslate"><span class="pre">tracklib.analysis.neda</span></code> namespace, i.e. can be imported from there
(instead of <code class="docutils literal notranslate"><span class="pre">tracklib.analysis.neda.neda</span></code>).</p>
<dl class="class">
<dt id="tracklib.analysis.neda.neda.Environment">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.neda.</code><code class="sig-name descname">Environment</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">MCMCconfig</em>, <em class="sig-param">MCMCscheme=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Environment for inference runs</p>
<p>This is essentially a semi-disguised way of using global variables for the
<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> we are looking at, the inference <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">models.Model</span></code></a> we want to use, and
the <a class="reference internal" href="#tracklib.analysis.neda.neda.Environment.MCMCscheme" title="tracklib.analysis.neda.neda.Environment.MCMCscheme"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">MCMCscheme</span></code></a> together with the <a class="reference internal" href="#tracklib.analysis.neda.neda.Environment.MCMCconfig" title="tracklib.analysis.neda.neda.Environment.MCMCconfig"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">MCMCconfig</span></code></a>. We use this approach
mainly for code readability / useability.</p>
<dl class="attribute">
<dt id="tracklib.analysis.neda.neda.Environment.traj">
<code class="sig-name descname">traj</code><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.traj" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory">Trajectory</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.neda.Environment.model">
<code class="sig-name descname">model</code><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.model" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model">models.Model</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.neda.Environment.MCMCconfig">
<code class="sig-name descname">MCMCconfig</code><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.MCMCconfig" title="Permalink to this definition">¶</a></dt>
<dd><p>see <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref any py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.neda.Environment.MCMCscheme">
<code class="sig-name descname">MCMCscheme</code><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.MCMCscheme" title="Permalink to this definition">¶</a></dt>
<dd><p>defaults to an instance of <a class="reference internal" href="#tracklib.analysis.neda.mcmc.TPWMCMC" title="tracklib.analysis.neda.mcmc.TPWMCMC"><code class="xref any py py-class docutils literal notranslate"><span class="pre">mcmc.TPWMCMC</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme">mcmc.MCMCScheme</a>, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.neda.Environment.runMCMC">
<code class="sig-name descname">runMCMC</code><span class="sig-paren">(</span><em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.runMCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the <a class="reference internal" href="#tracklib.analysis.neda.neda.Environment.MCMCscheme" title="tracklib.analysis.neda.neda.Environment.MCMCscheme"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">MCMCscheme</span></code></a> with a given <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.prior" title="tracklib.analysis.neda.mcmc.MCMCScheme.prior"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">prior</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>mcmc.MCMCRun</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.neda.Environment.posterior_density">
<code class="sig-name descname">posterior_density</code><span class="sig-paren">(</span><em class="sig-param">mcmcrun</em>, <em class="sig-param">prior</em>, <em class="sig-param">trace_eval</em>, <em class="sig-param">nSample_proposal=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.posterior_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the posterior density at a specific point from an <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mcmcrun</strong> (<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><em>MCMCRun</em></a>) – </p></li>
<li><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – </p></li>
<li><p><strong>trace_eval</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the point in parameter space for which to estimate the posterior
density</p></li>
<li><p><strong>nSample_proposal</strong> (<em>float</em><em>, </em><em>optional</em>) – how many samples from the proposal distribution to use for
evaluation of the exit rate. Defaults to exhaustive sampling, so
may be reduced if that seems excessive.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the estimated posterior density for <code class="xref any docutils literal notranslate"><span class="pre">trace_eval</span></code>. Might be
<code class="docutils literal notranslate"><span class="pre">np.inf</span></code> if the MCMC ensemble collapsed to a single sample.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This estimation follows eq. (9) of <a class="footnote-reference brackets" href="#id4" id="id3">1</a>. Essentially, we estimate the
density at the sample point as the number of times it is entered from
another point in the steady state ensemble, times the average number of
steps it takes to leave this point again, divided by the total sample
number <span class="math notranslate nohighlight">\(M\)</span>. This yields</p>
<div class="math notranslate nohighlight">
\[\hat{p}(\theta^*) = \frac{N_\text{enter}N_\text{stay}}{M} = \frac{P_\text{enter}}{k_\text{exit}} = \frac{M^{-1}\sum_{m=1}^M\, \alpha(\theta^{(m)}, \theta^*) q(\theta^{(m)}, \theta^*)}{J^{-1}\sum_{j=1}^J\, \alpha(\theta^*, \theta^{(j)})}\,,\]</div>
<p>where the <span class="math notranslate nohighlight">\(\theta^{(m)}\)</span> in the numerator are the samples from
the given MCMC run (i.e. are assumed to be sampled from the posterior
distribution), while <span class="math notranslate nohighlight">\(\theta^{(j)}\)</span> in the denominator are
independent samples from the proposal distribution
<span class="math notranslate nohighlight">\(q(\theta_\text{from} = \theta^*, \theta_\text{to})\)</span>
around the evaluation point <span class="math notranslate nohighlight">\(\theta^*\)</span>. Finally,
<span class="math notranslate nohighlight">\(\alpha(\theta_\text{from}, \theta_\text{to})\)</span> is the
acceptance probability for a given step.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>Chib, S. &amp; Jeliazkov, I. Marginal Likelihood From the Metropolis-Hastings Output. Journal of the American Statistical Association 96, 270-281 (2001)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.neda.Environment.evidence">
<code class="sig-name descname">evidence</code><span class="sig-paren">(</span><em class="sig-param">prior</em>, <em class="sig-param">mcmcrun</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.evidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the (log-)evidence from an <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – the prior over <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtraces</span></code></a> used for the MCMC run</p></li>
<li><p><strong>mcmcrun</strong> (<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><em>MCMCRun</em></a>) – the MCMC sample</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the estimated log-evidence</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The log-evidence is given by <code class="docutils literal notranslate"><span class="pre">log(likelihood)</span> <span class="pre">+</span> <span class="pre">log(prior)</span> <span class="pre">-</span>
<span class="pre">log(posterior)</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.neda.Environment.posterior_density" title="tracklib.analysis.neda.neda.Environment.posterior_density"><code class="xref py py-meth docutils literal notranslate"><span class="pre">posterior_density()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.neda.Environment.evidence_differential">
<code class="sig-name descname">evidence_differential</code><span class="sig-paren">(</span><em class="sig-param">prior</em>, <em class="sig-param">ref_prior</em>, <em class="sig-param">ref_mcmcrun</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.evidence_differential" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the relative evidence given a reference point</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – the prior whose evidence we want to estimate</p></li>
<li><p><strong>ref_prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – the reference point in prior space</p></li>
<li><p><strong>ref_mcmcrun</strong> (<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><em>MCMCRun</em></a>) – an <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a> using the reference prior</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the estimated log-evidence, relative to the reference</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The relative evidence is given by the expectation value of the prior
ratio over the MCMC sample: <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">=</span> <span class="pre">&lt;</span> <span class="pre">prior/ref_prior</span> <span class="pre">&gt;</span></code> where <code class="docutils literal notranslate"><span class="pre">&lt;.&gt;</span></code>
indicates an average over the MCMC sample.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt>
<code class="sig-prename descclassname">tracklib.analysis.neda.neda.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">priorfam</em>, <em class="sig-param">MCMCconfig</em>, <em class="sig-param">MCMCscheme=None</em>, <em class="sig-param">max_iterations=20</em>, <em class="sig-param">min_iterations=5</em>, <em class="sig-param">return_='nothing'</em>, <em class="sig-param">show_progress=False</em>, <em class="sig-param">assume_notebook_for_progressbar=True</em><span class="sig-paren">)</span></dt>
<dd><p>Run the neda looping inference scheme</p>
<p>The output of the inference run will be assembled into a dict whose fields
are detailed below. Where exactly this dict will end up depends on the
setting of <code class="xref any docutils literal notranslate"><span class="pre">return_</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – the <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> whose looping profile to infer</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><em>models.Model</em></a>) – the inference model to use</p></li>
<li><p><strong>priorfam</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.ParametricFamily" title="tracklib.analysis.neda.util.ParametricFamily"><em>ParametricFamily</em></a>) – a family of priors</p></li>
<li><p><strong>MCMCconfig</strong> (<em>dict</em>) – configuration for the MCMC runs. See <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref any py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p></li>
<li><p><strong>MCMCscheme</strong> (<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><em>mcmc.MCMCScheme</em></a><em>, </em><em>optional</em>) – the sampling scheme to use, i.e. an object implementing the
<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><code class="xref any py py-class docutils literal notranslate"><span class="pre">mcmc.MCMCScheme</span></code></a> interface. Defaults to <a href="#id5"><span class="problematic" id="id6">`</span></a>mcmc.TPWMCMC’</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – maximum number of iterations to run</p></li>
<li><p><strong>min_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – run at least this many iterations</p></li>
<li><p><strong>return_</strong> (<em>{'nothing'</em><em>, </em><em>'None'</em><em>, </em><em>'traj'</em><em>, </em><em>'dict'}</em>) – what the return value of this function should be. Generally, the
results of the inference run will be stored in a dict. If
<code class="docutils literal notranslate"><span class="pre">return_='dict'</span></code>, that dict is directly returned. Otherwise it is
written to <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code>, and if <code class="docutils literal notranslate"><span class="pre">return_='traj'</span></code> the
trajectory is returned (useful for parallelization). Otherwise this
function returns nothing, i.e. the inference results can be accessed
simply from <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code> after calling this function.</p></li>
<li><p><strong>show_progress</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to show a progress bar. Note: for <code class="docutils literal notranslate"><span class="pre">show_progress=True</span></code> it
might happen that the termination condition is fulfilled during the
last “required” run, in which case the progress bar will stop before
reaching its maximum.</p></li>
<li><p><strong>assume_notebook_for_progressbar</strong> (<em>bool</em><em>, </em><em>optional</em>) – set to <code class="docutils literal notranslate"><span class="pre">False</span></code> if running outside Jupyter notebook to show
progressbar ASCII style</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>prior_prams</strong> (<em>np.array</em>) – the prior parameters for each iteration</p></li>
<li><p><strong>mcmcrun</strong> (<em>list of MCMCRun</em>) – the MCMC runs for each iteration</p></li>
<li><p><strong>evidence</strong> (<em>np.array</em>) – the evidence estimated from each <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p></li>
<li><p><strong>evidence_diff</strong> (<em>np.array</em>) – the estimated evidence differential (relative evidence) at each
iteration</p></li>
<li><p><strong>final</strong> (<em>dict</em>) – the corresponding values for the iteration that should be considered
the final result. Has entries <code class="docutils literal notranslate"><span class="pre">'prior_params'</span></code>, <code class="docutils literal notranslate"><span class="pre">'mcmcrun'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'evidence'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'iteration'</span></code> where the last one is the index of
the iteration the other three refer to.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Assuming we have a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> <code class="docutils literal notranslate"><span class="pre">traj</span></code> that we want to run the looping
inference on:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Set up inference scheme</span>
<span class="gp">... </span><span class="n">looppositions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># 2 states: unlooped (=0), fully looped (=1)</span>
<span class="gp">... </span><span class="n">model</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">RouseModel</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">k_extra</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">looppositions</span><span class="o">=</span><span class="n">looppositions</span><span class="p">)</span>
<span class="gp">... </span><span class="n">priorfam</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">ParametricFamily</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">... </span><span class="n">priorfam</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">logq</span> <span class="p">:</span> <span class="n">neda</span><span class="o">.</span><span class="n">priors</span><span class="o">.</span><span class="n">GeometricPrior</span><span class="p">(</span><span class="n">logq</span><span class="p">,</span> <span class="n">nStates</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">looppositions</span><span class="p">))</span>
<span class="gp">... </span><span class="n">MCMCconfig</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>        <span class="s1">&#39;iterations&#39;</span> <span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;burn_in&#39;</span>    <span class="p">:</span>  <span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">}</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Run the inference</span>
<span class="gp">... </span><span class="n">neda</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">priorfam</span><span class="p">,</span> <span class="n">MCMCconfig</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Visualize output</span>
<span class="gp">... </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="gp">... </span><span class="n">neda</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">butterfly</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
<span class="gp">... </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="tracklib.analysis.html#tracklib.analysis.kli.fit_RouseParams" title="tracklib.analysis.kli.fit_RouseParams"><code class="xref py py-func docutils literal notranslate"><span class="pre">tracklib.analysis.kli.fit_RouseParams()</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.plot">
<span id="tracklib-analysis-neda-plot"></span><h2><a class="toc-backref" href="#id10">tracklib.analysis.neda.plot</a><a class="headerlink" href="#module-tracklib.analysis.neda.plot" title="Permalink to this headline">¶</a></h2>
<p>Visualizing inference runs</p>
<dl class="function">
<dt id="tracklib.analysis.neda.plot.butterfly">
<code class="sig-prename descclassname">tracklib.analysis.neda.plot.</code><code class="sig-name descname">butterfly</code><span class="sig-paren">(</span><em class="sig-param">traj, fig=None, title='Example trajectory', ylim=[0, None], ylabel='distance', states_cmap='Greens'</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.plot.butterfly" title="Permalink to this definition">¶</a></dt>
<dd><p>General overview over an inference run</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – should have <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code> meta data, i.e. have gone through
<a class="reference internal" href="#tracklib.analysis.neda.neda.main" title="tracklib.analysis.neda.neda.main"><code class="xref any py py-func docutils literal notranslate"><span class="pre">neda.main</span></code></a></p></li>
<li><p><strong>fig</strong> (<em>figure handle</em><em>, </em><em>optional</em>) – the figure to plot into. Will create a new one by default</p></li>
<li><p><strong>title</strong> (<em>string</em><em>, </em><em>optional</em>) – the title for the plot</p></li>
<li><p><strong>ylim</strong> (<em>[</em><em>lower</em><em>, </em><em>higher</em><em>]</em><em>, </em><em>optional</em>) – the y-limits for the plot of the trajectory (can be used to prevent
outliers from distorting the scale)</p></li>
<li><p><strong>ylabel</strong> (<em>string</em><em>, </em><em>optional</em>) – label to attach to the y-axis of the trajectory plot</p></li>
<li><p><strong>states_cmap</strong> (<em>string</em><em>, </em><em>optional</em>) – an identifier for the colormap to use for the display of marginal
probabilities</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.postproc">
<span id="tracklib-analysis-neda-postproc"></span><h2><a class="toc-backref" href="#id11">tracklib.analysis.neda.postproc</a><a class="headerlink" href="#module-tracklib.analysis.neda.postproc" title="Permalink to this headline">¶</a></h2>
<p>A module collecting some useful post-processing functions.</p>
<dl class="function">
<dt id="tracklib.analysis.neda.postproc.logLR_clusterflip">
<code class="sig-prename descclassname">tracklib.analysis.neda.postproc.</code><code class="sig-name descname">logLR_clusterflip</code><span class="sig-paren">(</span><em class="sig-param">lt</em>, <em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.postproc.logLR_clusterflip" title="Permalink to this definition">¶</a></dt>
<dd><p>Likelihood ratio for clusterflips</p>
<p>Calculate the log likelihood ratio for clusterflips, i.e. replacing whole
intervals with a different state</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lt</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the profile to start from</p></li>
<li><p><strong>model</strong><strong>, </strong><strong>prior</strong> (<em>traj</em><em>,</em>) – the context for likelihood calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>(N, n) np.ndarray</em> – the likelihood ratios. <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of contiguous intervals in
the <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">lt.n</span> <span class="pre">-</span> <span class="pre">1</span></code> is the number of alternative
states each interval could have.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.neda.postproc.optimize_clusterflip">
<code class="sig-prename descclassname">tracklib.analysis.neda.postproc.</code><code class="sig-name descname">optimize_clusterflip</code><span class="sig-paren">(</span><em class="sig-param">lt</em>, <em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.postproc.optimize_clusterflip" title="Permalink to this definition">¶</a></dt>
<dd><p>Deterministic optimization using (only) clusterflips</p>
<p>We evaluate <a class="reference internal" href="#tracklib.analysis.neda.postproc.logLR_clusterflip" title="tracklib.analysis.neda.postproc.logLR_clusterflip"><code class="xref any py py-func docutils literal notranslate"><span class="pre">logLR_clusterflip</span></code></a> and perform the (one) best flip it found
(if <code class="docutils literal notranslate"><span class="pre">log(LR)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>). Then repeat until no improvement possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lt</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the profile to be optimized</p></li>
<li><p><strong>model</strong><strong>, </strong><strong>prior</strong> (<em>traj</em><em>,</em>) – the context for likelihood calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em> – a new, optimized <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.neda.postproc.logLR_nbit">
<code class="sig-prename descclassname">tracklib.analysis.neda.postproc.</code><code class="sig-name descname">logLR_nbit</code><span class="sig-paren">(</span><em class="sig-param">lt</em>, <em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.postproc.logLR_nbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Give likelihood ratios for exhaustive resampling of n-bit moving window</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lt</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the profile to start from</p></li>
<li><p><strong>model</strong><strong>, </strong><strong>prior</strong> (<em>traj</em><em>,</em>) – the context for likelihood calculation</p></li>
<li><p><strong>n</strong> (<em>int</em>) – the window size, i.e. number of contiguous bits to sample exhaustively</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>(N, n) np.ndarray</em> – the likelihood ratios, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(lt)-n+1</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">(lt.n)^n</span></code> (we
insert the value of the unchanged window for completeness).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This scales as <code class="docutils literal notranslate"><span class="pre">O(len(lt)</span> <span class="pre">*</span> <span class="pre">lt.n</span> <span class="pre">^</span> <span class="pre">n)</span></code>, i.e. becomes very expensive very
fast.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.neda.postproc.optimize_nbit">
<code class="sig-prename descclassname">tracklib.analysis.neda.postproc.</code><code class="sig-name descname">optimize_nbit</code><span class="sig-paren">(</span><em class="sig-param">lt</em>, <em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.postproc.optimize_nbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Deterministic optimization using n-bit flips</p>
<p>We evaluate <a class="reference internal" href="#tracklib.analysis.neda.postproc.logLR_nbit" title="tracklib.analysis.neda.postproc.logLR_nbit"><code class="xref any py py-func docutils literal notranslate"><span class="pre">logLR_nbit</span></code></a> and perform the (one) best flip it found (if
<code class="docutils literal notranslate"><span class="pre">log(LR)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>). Then repeat until no improvement possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lt</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the profile to be optimized</p></li>
<li><p><strong>model</strong><strong>, </strong><strong>prior</strong> (<em>traj</em><em>,</em>) – the context for likelihood calculation</p></li>
<li><p><strong>n</strong> (<em>int</em>) – the window size, i.e. number of contiguous bits to sample exhaustively</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em> – a new, optimized <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.neda.postproc.logLR_boundary">
<code class="sig-prename descclassname">tracklib.analysis.neda.postproc.</code><code class="sig-name descname">logLR_boundary</code><span class="sig-paren">(</span><em class="sig-param">lt</em>, <em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.postproc.logLR_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Give likelihood ratios for boundary moves</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lt</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the profile to start from</p></li>
<li><p><strong>model</strong><strong>, </strong><strong>prior</strong> (<em>traj</em><em>,</em>) – the context for likelihood calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>(N, 2) np.ndarray</em> – the likelihood ratios, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of boundaries within
the profile and the two entries are the likelihood ratios for moving
left and right respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tracklib.analysis.neda.postproc.optimize_boundary">
<code class="sig-prename descclassname">tracklib.analysis.neda.postproc.</code><code class="sig-name descname">optimize_boundary</code><span class="sig-paren">(</span><em class="sig-param">lt</em>, <em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.postproc.optimize_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Deterministic optimization using boundary moves</p>
<p>We evaluate <a class="reference internal" href="#tracklib.analysis.neda.postproc.logLR_boundary" title="tracklib.analysis.neda.postproc.logLR_boundary"><code class="xref any py py-func docutils literal notranslate"><span class="pre">logLR_boundary</span></code></a> and perform the (one) best boundary move it
found (if <code class="docutils literal notranslate"><span class="pre">log(LR)</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>). Then repeat until no improvement possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lt</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the profile to be optimized</p></li>
<li><p><strong>model</strong><strong>, </strong><strong>prior</strong> (<em>traj</em><em>,</em>) – the context for likelihood calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em> – a new, optimized <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.priors">
<span id="tracklib-analysis-neda-priors"></span><h2><a class="toc-backref" href="#id12">tracklib.analysis.neda.priors</a><a class="headerlink" href="#module-tracklib.analysis.neda.priors" title="Permalink to this headline">¶</a></h2>
<p>Everything to do with priors</p>
<dl class="class">
<dt id="tracklib.analysis.neda.priors.Prior">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.priors.</code><code class="sig-name descname">Prior</code><a class="headerlink" href="#tracklib.analysis.neda.priors.Prior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class for priors</p>
<p>When subclassing, you need to provide the <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi" title="tracklib.analysis.neda.priors.Prior.logpi"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logpi</span></code></a> method, which should
return the (log) prior probability for an input <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>. Specifying
<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi_vectorized" title="tracklib.analysis.neda.priors.Prior.logpi_vectorized"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logpi_vectorized</span></code></a> is optional, if you can speed up the prior calculation
over an iterable of loopingtraces.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.priors.Prior.logpi">
<em class="property">abstract </em><code class="sig-name descname">logpi</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.Prior.logpi" title="Permalink to this definition">¶</a></dt>
<dd><p>log of prior probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi_vectorized" title="tracklib.analysis.neda.priors.Prior.logpi_vectorized"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi_vectorized()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.priors.Prior.logpi_vectorized">
<code class="sig-name descname">logpi_vectorized</code><span class="sig-paren">(</span><em class="sig-param">loopingtraces</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.Prior.logpi_vectorized" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior on multiple loopingtraces</p>
<p>By default just sequentially evaluates <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi" title="tracklib.analysis.neda.priors.Prior.logpi"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logpi</span></code></a> on the given
loopingtraces, which of course does not give a speedup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtraces</strong> (<em>Sequence</em><em> (</em><em>e.g. list</em><em>) </em><em>of Loopingtrace</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>np.ndarray, dtype=float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi" title="tracklib.analysis.neda.priors.Prior.logpi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.priors.UniformPrior">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.priors.</code><code class="sig-name descname">UniformPrior</code><a class="headerlink" href="#tracklib.analysis.neda.priors.UniformPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.priors.Prior</span></code></a></p>
<p>A uniform prior over loopingtraces</p>
<p>This is simply <span class="math notranslate nohighlight">\(-N\log(n)\)</span> for each <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of states and <span class="math notranslate nohighlight">\(N\)</span> the number of (valid) frames.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.priors.UniformPrior.logpi">
<code class="sig-name descname">logpi</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.UniformPrior.logpi" title="Permalink to this definition">¶</a></dt>
<dd><p>log of prior probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi_vectorized()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.priors.GeometricPrior">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.priors.</code><code class="sig-name descname">GeometricPrior</code><span class="sig-paren">(</span><em class="sig-param">logq=0</em>, <em class="sig-param">nStates=2</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.priors.Prior</span></code></a></p>
<p>A geometric prior over #switches in the <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p>
<p>Writing <span class="math notranslate nohighlight">\(\theta\)</span> for the <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> and <span class="math notranslate nohighlight">\(k(\theta)\)</span> for the
number of switches therein, this is given by</p>
<div class="math notranslate nohighlight">
\[\pi(\theta) = \frac{1}{n}(1+(n-1)q)^{N-1} q^{k(\theta)}\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(q\in(0, 1]\)</span> is the one parameter of this prior, <span class="math notranslate nohighlight">\(n\)</span> is
the number of possible states and <span class="math notranslate nohighlight">\(N\)</span> is the number of (valid) frames
in the trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logq</strong> (<em>float &lt; 0</em>) – log of the parameter q</p></li>
<li><p><strong>nStates</strong> (<em>int</em><em>, </em><em>optional</em>) – the number of possible states</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.logq">
<code class="sig-name descname">logq</code><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.logq" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.n">
<code class="sig-name descname">n</code><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.logpi">
<code class="sig-name descname">logpi</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi" title="Permalink to this definition">¶</a></dt>
<dd><p>log of prior probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi_vectorized" title="tracklib.analysis.neda.priors.GeometricPrior.logpi_vectorized"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi_vectorized()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.logpi_vectorized">
<code class="sig-name descname">logpi_vectorized</code><span class="sig-paren">(</span><em class="sig-param">loopingtraces</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi_vectorized" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior on multiple loopingtraces</p>
<p>By default just sequentially evaluates <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi" title="tracklib.analysis.neda.priors.GeometricPrior.logpi"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logpi</span></code></a> on the given
loopingtraces, which of course does not give a speedup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtraces</strong> (<em>Sequence</em><em> (</em><em>e.g. list</em><em>) </em><em>of Loopingtrace</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>np.ndarray, dtype=float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi" title="tracklib.analysis.neda.priors.GeometricPrior.logpi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.family">
<em class="property">classmethod </em><code class="sig-name descname">family</code><span class="sig-paren">(</span><em class="sig-param">nStates=2</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.family" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a <a class="reference internal" href="#tracklib.analysis.neda.util.ParametricFamily" title="tracklib.analysis.neda.util.ParametricFamily"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ParametricFamily</span></code></a> for <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior" title="tracklib.analysis.neda.priors.GeometricPrior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GeometricPrior</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nStates</strong> (<em>int</em><em>, </em><em>optional</em>) – the number of states the priors will assume</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>ParametricFamily</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">ParametricFamily()</span></code></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.util">
<span id="tracklib-analysis-neda-util"></span><h2><a class="toc-backref" href="#id13">tracklib.analysis.neda.util</a><a class="headerlink" href="#module-tracklib.analysis.neda.util" title="Permalink to this headline">¶</a></h2>
<p>Useful constructs used throughout the <a class="reference internal" href="#module-tracklib.analysis.neda.neda" title="tracklib.analysis.neda.neda"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">neda</span></code></a> module</p>
<dl class="class">
<dt id="tracklib.analysis.neda.util.Loopingtrace">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.util.</code><code class="sig-name descname">Loopingtrace</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Trace of looping states</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> objects associate an integer state with each valid (i.e.
non-<code class="docutils literal notranslate"><span class="pre">nan</span></code>) time point in a given trajectory. To this end, it keeps a list
of those valid time points alongside the list of states.</p>
<p>In the context of looping inference, the states indicate which out of a
list of models to use for evolution up to the labelled point. For the first
data point this means that the associated model specifies the equilibrium
state we start from.</p>
<dl class="attribute">
<dt id="tracklib.analysis.neda.util.Loopingtrace.T">
<code class="sig-name descname">T</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.T" title="Permalink to this definition">¶</a></dt>
<dd><p>total length of the associated <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.util.Loopingtrace.n">
<code class="sig-name descname">n</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.n" title="Permalink to this definition">¶</a></dt>
<dd><p>total number of states (relevant e.g. for acceptance probabilities)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.util.Loopingtrace.t">
<code class="sig-name descname">t</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.t" title="Permalink to this definition">¶</a></dt>
<dd><p>valid frames of the associated <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(N,) np.ndarray, dtype=int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.util.Loopingtrace.state">
<code class="sig-name descname">state</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.state" title="Permalink to this definition">¶</a></dt>
<dd><p>state associated with each (valid) frame of the trajectory. By default
initialized with zeroes, unless <code class="xref any docutils literal notranslate"><span class="pre">thresholds</span></code> specified</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(N,) np.ndarray, dtype=int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This class forwards the <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> interface of its <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace.state" title="tracklib.analysis.neda.util.Loopingtrace.state"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">state</span></code></a> attribute,
i.e. for a <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> <code class="docutils literal notranslate"><span class="pre">lt</span></code> <code class="docutils literal notranslate"><span class="pre">len(lt)</span></code> gives the number of valid
frames, <code class="docutils literal notranslate"><span class="pre">lt[i]</span></code> gives the state associated with the <code class="docutils literal notranslate"><span class="pre">i``th</span> <span class="pre">valid</span> <span class="pre">frame</span>
<span class="pre">and</span> <span class="pre">``lt[i]</span> <span class="pre">=</span> <span class="pre">2</span></code> can be used to assign that state. Note that this usage is
preferred over accessing <code class="docutils literal notranslate"><span class="pre">lt.state</span></code>, since it allows for more internal
control, such as type checks upon assignment.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.forTrajectory">
<em class="property">classmethod </em><code class="sig-name descname">forTrajectory</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">nStates=2</em>, <em class="sig-param">thresholds=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.forTrajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> for a given <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<em>tracklib.Trajectory</em>) – the <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> to which the <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> is associated. This
information is needed to assemble the list of valid time points.</p></li>
<li><p><strong>nStates</strong> (<em>int</em><em>, </em><em>optional</em>) – the number of possible states</p></li>
<li><p><strong>thresholds</strong> (<em>sized iterable</em><em> (</em><em>e.g. list</em><em>) </em><em>of float</em><em>, </em><em>optional</em>) – can be used to initialize the trajectory with states corresponding to a
set of absolute distance thresholds. The state of each frame will be
the number of given thresholds that are smaller than the absolute
distance, i.e. <code class="docutils literal notranslate"><span class="pre">thresholds=[5,</span> <span class="pre">10]</span></code> means <code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">&lt;=</span> <span class="pre">5</span></code> is state 0,
<code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">&lt;</span> <span class="pre">dist</span> <span class="pre">&lt;=</span> <span class="pre">10</span></code> state 1, <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">&lt;</span> <span class="pre">dist</span></code> state 2. Will overwrite
<code class="xref any docutils literal notranslate"><span class="pre">nStates</span></code> with <code class="docutils literal notranslate"><span class="pre">len(thresholds)+1</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.fromStates">
<em class="property">classmethod </em><code class="sig-name descname">fromStates</code><span class="sig-paren">(</span><em class="sig-param">states</em>, <em class="sig-param">nStates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.fromStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> just from a list of states</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>states</strong> (<em>array-like</em>) – does not have to be of integer type. This can be used to specify
missing frames as <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>.</p></li>
<li><p><strong>nStates</strong> (<em>int</em><em>, </em><em>optional</em>) – how many states there could be in the trajectory in principle. If
unspecified, defaults to <code class="docutils literal notranslate"><span class="pre">max(states)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy myself</p>
<p>Creates a copy of the calling object. Faster than
<code class="docutils literal notranslate"><span class="pre">deepcopy(loopingtrace)</span></code>, i.e. used for performance.</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.plottable">
<code class="sig-name descname">plottable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.plottable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return t, y for plotting as steps</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>t</strong> (<em>np.ndarray</em>)</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>For a <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> <code class="docutils literal notranslate"><span class="pre">lt</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="gp">... </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">lt</span><span class="o">.</span><span class="n">plottable</span><span class="p">(),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.full_valid">
<code class="sig-name descname">full_valid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.full_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a full-length array of states</p>
<p>This returns an array of looping states of length equal to the
associated trajectory. Invalid frames in the trajectory (i.e. those
containing <code class="docutils literal notranslate"><span class="pre">nan</span></code>) will be labelled with the same state as the next
valid one. This implements the interpretation that the state associated
with a frame specifies the model governing the evolution up to that
frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>states</strong> (<em>(self.T,) np.ndarray</em>) – a valid states associated with each frame in the trajectory, even
the invalid ones.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.loops">
<code class="sig-name descname">loops</code><span class="sig-paren">(</span><em class="sig-param">return_='time'</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Give intervals where state stays constant</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>return_</strong> (<em>{'time'</em><em>, </em><em>'index'}</em><em>, </em><em>optional</em>) – whether the returned interval boundaries should be times (i.e.
indices into the associated trajectory) or indices into the
<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> itself.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>(N, 3) np.ndarray</em> – the detected loops. Each entry consists of <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">end,</span> <span class="pre">state)</span></code>,
such that <code class="docutils literal notranslate"><span class="pre">self[start:end]</span> <span class="pre">==</span> <span class="pre">state</span></code>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>By default, this returns times, i.e. indices into the associated
trajectory, not indices into the <code class="xref any docutils literal notranslate"><span class="pre">Loopingprofile</span></code>! To achieve the
latter, set <code class="docutils literal notranslate"><span class="pre">return_='index'</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.util.ParametricFamily">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.util.</code><code class="sig-name descname">ParametricFamily</code><span class="sig-paren">(</span><em class="sig-param">start_params</em>, <em class="sig-param">bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.ParametricFamily" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A base class for parametric families</p>
<p>This class is a template for parametric families of any type, i.e. its main
capability (<a class="reference internal" href="#tracklib.analysis.neda.util.ParametricFamily.get" title="tracklib.analysis.neda.util.ParametricFamily.get"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">get</span></code></a>) converts a set of parameters into an object, e.g. a
<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Prior</span></code></a> or <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>. On top of that, meta information like
bounds for parameters is stored here. In summary, this class provides the
interface we need generically for fitting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_params</strong> (<em>tuple of float</em>) – the initial parameters</p></li>
<li><p><strong>bounds</strong> (<em>list of</em><em> (</em><em>lower</em><em>, </em><em>higher</em><em>) </em><em>tuples</em>) – domain for each parameter</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.util.ParametricFamily.start_params">
<code class="sig-name descname">start_params</code><a class="headerlink" href="#tracklib.analysis.neda.util.ParametricFamily.start_params" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple of float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.util.ParametricFamily.nParams">
<code class="sig-name descname">nParams</code><a class="headerlink" href="#tracklib.analysis.neda.util.ParametricFamily.nParams" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.util.ParametricFamily.bounds">
<code class="sig-name descname">bounds</code><a class="headerlink" href="#tracklib.analysis.neda.util.ParametricFamily.bounds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of (lower, higher) tuples</p>
</dd>
</dl>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">fit_model</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This class uses the call syntax as an alias for <a class="reference internal" href="#tracklib.analysis.neda.util.ParametricFamily.get" title="tracklib.analysis.neda.util.ParametricFamily.get"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">get</span></code></a>, i.e. in the examples
below <code class="docutils literal notranslate"><span class="pre">fam(...)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">fam.get(...)</span></code>.</p>
<p class="rubric">Example</p>
<p>A family of <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior" title="tracklib.analysis.neda.priors.GeometricPrior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">priors.GeometricPrior</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fam</span> <span class="o">=</span> <span class="n">ParametricFamily</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">... </span><span class="n">fam</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">logq</span> <span class="p">:</span> <span class="n">priors</span><span class="o">.</span><span class="n">GeometricPrior</span><span class="p">(</span><span class="n">logq</span><span class="p">,</span> <span class="n">nStates</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior" title="tracklib.analysis.neda.priors.GeometricPrior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GeometricPrior</span></code></a> also has a <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior.family" title="tracklib.analysis.neda.priors.GeometricPrior.family"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">family</span></code></a> method providing essentially
this construction.</p>
<p>A family of three state <a class="reference internal" href="#tracklib.analysis.neda.models.RouseModel" title="tracklib.analysis.neda.models.RouseModel"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RouseModels</span></code></a>, which is then
fitted to a calibration dataset <code class="xref any docutils literal notranslate"><span class="pre">data</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fam</span> <span class="o">=</span> <span class="n">ParametricFamily</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">[(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
<span class="gp">... </span><span class="n">fam</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">D</span><span class="p">,</span> <span class="n">k</span> <span class="p">:</span> <span class="n">models</span><span class="o">.</span><span class="n">RouseModel</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">looppositions</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">... </span><span class="n">fitresult</span> <span class="o">=</span> <span class="n">fit_model</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fam</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that you cannot use the framework provided here to optimize e.g. the
number of monomers <code class="xref any docutils literal notranslate"><span class="pre">N</span></code>, since that is an integer programming problem. One
could imagine comparing runs with different (fixed) <code class="xref any docutils literal notranslate"><span class="pre">N</span></code> though.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.util.ParametricFamily.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">*params</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.ParametricFamily.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an object from the given parameters</p>
<p>This function should be overwritten upon instantiation</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">tracklib.analysis.neda</a><ul>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.mcmc">tracklib.analysis.neda.mcmc</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.models">tracklib.analysis.neda.models</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.neda">tracklib.analysis.neda.neda</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.plot">tracklib.analysis.neda.plot</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.postproc">tracklib.analysis.neda.postproc</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.priors">tracklib.analysis.neda.priors</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.util">tracklib.analysis.neda.util</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tracklib.analysis.html"
                        title="previous chapter">tracklib.analysis</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tracklib.io.html"
                        title="next chapter">tracklib.io</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tracklib.analysis.neda.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tracklib.io.html" title="tracklib.io"
             >next</a> |</li>
        <li class="right" >
          <a href="tracklib.analysis.html" title="tracklib.analysis"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">tracklib 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tracklib.html" >tracklib</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tracklib.analysis.html" >tracklib.analysis</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Simon Grosse-Holz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>