
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tracklib.analysis.neda &#8212; tracklib 0.1 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="tracklib.io" href="tracklib.io.html" />
    <link rel="prev" title="tracklib.analysis" href="tracklib.analysis.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tracklib.io.html" title="tracklib.io"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tracklib.analysis.html" title="tracklib.analysis"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">tracklib 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tracklib.html" >tracklib</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tracklib.analysis.html" accesskey="U">tracklib.analysis</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tracklib-analysis-neda">
<h1>tracklib.analysis.neda<a class="headerlink" href="#tracklib-analysis-neda" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.mcmc" id="id3">tracklib.analysis.neda.mcmc</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.models" id="id4">tracklib.analysis.neda.models</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.neda" id="id5">tracklib.analysis.neda.neda</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.plot" id="id6">tracklib.analysis.neda.plot</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.priors" id="id7">tracklib.analysis.neda.priors</a></p></li>
<li><p><a class="reference internal" href="#module-tracklib.analysis.neda.util" id="id8">tracklib.analysis.neda.util</a></p></li>
</ul>
</div>
<dl class="function">
<dt id="tracklib.analysis.neda.neda.main">
<code class="sig-prename descclassname">tracklib.analysis.neda.neda.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">priorfac</em>, <em class="sig-param">MCMCconfig</em>, <em class="sig-param">MCMCscheme=&lt;class 'tracklib.analysis.neda.mcmc.TPWMCMC'&gt;</em>, <em class="sig-param">max_iterations=20</em>, <em class="sig-param">min_iterations=5</em>, <em class="sig-param">return_='nothing'</em>, <em class="sig-param">show_progress=False</em>, <em class="sig-param">assume_notebook_for_progressbar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the neda looping inference scheme</p>
<p>The output of the inference run will be assembled into a dict whose fields
are detailed below. Where exactly this dict will end up depends on the
setting of <code class="xref any docutils literal notranslate"><span class="pre">return_</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – the <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> whose looping profile to infer</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><em>models.Model</em></a>) – the inference model to use</p></li>
<li><p><strong>priorfac</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.PriorFactory" title="tracklib.analysis.neda.priors.PriorFactory"><em>PriorFactory</em></a>) – a family of priors</p></li>
<li><p><strong>MCMCconfig</strong> (<em>dict</em>) – configuration for the MCMC runs. See <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref any py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p></li>
<li><p><strong>MCMCscheme</strong> (<em>type</em><em>, </em><em>optional</em>) – a class implementing the <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCScheme</span></code></a> interface (i.e. a subclass of
this abstract base class). Defines the MCMC sampling scheme</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – maximum number of iterations to run</p></li>
<li><p><strong>min_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – run at least this many iterations</p></li>
<li><p><strong>return_</strong> (<em>{'nothing'</em><em>, </em><em>'None'</em><em>, </em><em>'traj'</em><em>, </em><em>'dict'}</em>) – what the return value of this function should be. Generally, the
results of the inference run will be stored in a dict. If
<code class="docutils literal notranslate"><span class="pre">return_='dict'</span></code>, that dict is directly returned. Otherwise it is
written to <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code>, and if <code class="docutils literal notranslate"><span class="pre">return_='traj'</span></code> the
trajectory is returned (useful for parallelization). Otherwise this
function returns nothing, i.e. the inference results can be accessed
simply from <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code> after calling this function.</p></li>
<li><p><strong>show_progress</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to show a progress bar. Note: for <code class="docutils literal notranslate"><span class="pre">show_progress=True</span></code> it
might happen that the termination condition is fulfilled during the
last “required” run, in which case the progress bar will stop before
reaching its maximum.</p></li>
<li><p><strong>assume_notebook_for_progressbar</strong> (<em>bool</em><em>, </em><em>optional</em>) – set to <code class="docutils literal notranslate"><span class="pre">False</span></code> if running outside Jupyter notebook to show
progressbar ASCII style</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>prior_prams</strong> (<em>np.array</em>) – the prior parameters for each iteration</p></li>
<li><p><strong>mcmcrun</strong> (<em>list of MCMCRun</em>) – the MCMC runs for each iteration</p></li>
<li><p><strong>evidence</strong> (<em>np.array</em>) – the evidence estimated from each <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p></li>
<li><p><strong>evidence_diff</strong> (<em>np.array</em>) – the estimated evidence differential (relative evidence) at each
iteration</p></li>
<li><p><strong>final</strong> (<em>dict</em>) – the corresponding values for the iteration that should be considered
the final result. Has entries <code class="docutils literal notranslate"><span class="pre">'prior_params'</span></code>, <code class="docutils literal notranslate"><span class="pre">'mcmcrun'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'evidence'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'iteration'</span></code> where the last one is the index of
the iteration the other three refer to.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Assuming we have a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> <code class="docutils literal notranslate"><span class="pre">traj</span></code> that we want to run the looping
inference on:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Set up inference scheme</span>
<span class="gp">... </span><span class="n">looppositions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># 2 states: unlooped (=0), fully looped (=1)</span>
<span class="gp">... </span><span class="n">model</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">RouseModel</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">k_extra</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">looppositions</span><span class="o">=</span><span class="n">looppositions</span><span class="p">)</span>
<span class="gp">... </span><span class="n">priorfac</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">priors</span><span class="o">.</span><span class="n">PriorFactory</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">... </span><span class="n">priorfac</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">logq</span> <span class="p">:</span> <span class="n">neda</span><span class="o">.</span><span class="n">priors</span><span class="o">.</span><span class="n">GeometricPrior</span><span class="p">(</span><span class="n">logq</span><span class="p">,</span> <span class="n">nStates</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">looppositions</span><span class="p">))</span>
<span class="gp">... </span><span class="n">MCMCconfig</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>        <span class="s1">&#39;iterations&#39;</span> <span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;burn_in&#39;</span>    <span class="p">:</span>  <span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">}</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Run the inference</span>
<span class="gp">... </span><span class="n">neda</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">priorfac</span><span class="p">,</span> <span class="n">MCMCconfig</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Visualize output</span>
<span class="gp">... </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="gp">... </span><span class="n">neda</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">butterfly</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
<span class="gp">... </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="module-tracklib.analysis.neda.mcmc">
<span id="tracklib-analysis-neda-mcmc"></span><h2><a class="toc-backref" href="#id3">tracklib.analysis.neda.mcmc</a><a class="headerlink" href="#module-tracklib.analysis.neda.mcmc" title="Permalink to this headline">¶</a></h2>
<p>Formalizing the process of running <a class="reference internal" href="tracklib.util.html#module-tracklib.util.mcmc" title="tracklib.util.mcmc"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">util.mcmc</span></code></a></p>
<dl class="class">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.mcmc.</code><code class="sig-name descname">MCMCRun</code><span class="sig-paren">(</span><em class="sig-param">logLs=None</em>, <em class="sig-param">samples=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The results of an MCMC run</p>
<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.logLs">
<code class="sig-name descname">logLs</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.logLs" title="Permalink to this definition">¶</a></dt>
<dd><p>the likelihoods from the run</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.samples">
<code class="sig-name descname">samples</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>the actual MCMC sample</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of &lt;sample data type&gt;</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.logLs_trunc">
<code class="sig-name descname">logLs_trunc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.logLs_trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Give only the likelihoods associated with the samples</p>
<p><a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler.run" title="tracklib.util.mcmc.Sampler.run"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler.run</span></code></a> returns likelihoods starting at the
first iteration, but samples only after a given burn-in period. This
function cuts this initial overhang from the likelihood array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>(len(samples),) np.ndarray</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.best_sample_L">
<code class="sig-name descname">best_sample_L</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.best_sample_L" title="Permalink to this definition">¶</a></dt>
<dd><p>Give the best sample (and likelihood)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>sample</strong> (<em>&lt;sample data type&gt;</em>) – the maximum likelihood estimate</p></li>
<li><p><strong>logL</strong> (<em>float</em>) – the maximum likelihood value</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.acceptance_rate">
<code class="sig-name descname">acceptance_rate</code><span class="sig-paren">(</span><em class="sig-param">criterion='sample_identity'</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.acceptance_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate fraction of accepted moves</p>
<p>We can see whether a move was accepted or rejected by checking whether
the samples are actually different. There are three different ways to
do so: syntactically correct would be sample comparison (using <code class="docutils literal notranslate"><span class="pre">==</span></code>).
However, since samples have a user-defined data type, we do not
necessarily have the == operator defined. For mutable objects we can
exploit that they would not be copied for an unaccepted step, i.e. we
can use identity check (<code class="docutils literal notranslate"><span class="pre">is</span></code>). As a last resort, we can use the
likelihood as a proxy: it is very unlikeliy that we did a move where
the likelihood remained exactly the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>criterion</strong> (<em>{'sample_equality'</em><em>, </em><em>'sample_identity'</em><em>, </em><em>'likelihood_equality'}</em>) – which method to use to determine whether a step was accepted or
rejected.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the acceptance rate</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCRun.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param">fun</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCRun.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a function on all samples</p>
<p>This exploits that (if the sample data type is e.g. a user-defined
class) many samples will actually be identical and we have to evaluate
the function significantly fewer than <code class="docutils literal notranslate"><span class="pre">len(samples)</span></code> times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fun</strong> (callable of signature <code class="docutils literal notranslate"><span class="pre">fun(sample)</span> <span class="pre">--&gt;</span> <span class="pre">object</span></code>) – the function to evaluate. It should expect a single sample as input
and return something.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>list</em> – a list of output values, in the order of <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun.samples" title="tracklib.analysis.neda.mcmc.MCMCRun.samples"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">samples</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is supposed to decrease computational cost. It is usually
quicker however, to use a vectorized function <code class="docutils literal notranslate"><span class="pre">fun</span></code> instead.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.mcmc.</code><code class="sig-name descname">MCMCScheme</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p>
<p>Abstract base class for <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> MCMC schemes.</p>
<p>We might want to test different MCMC schemes, so this class intends to
reduce the overhead of introducing a new sampling scheme to a minimum. A
sampling scheme is given by its proposal distribution, so this is the
minimum information needed. This should be specified in two forms:
<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability" title="tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">stepping_probability</span></code></a> evaluates the actual proposal distribution, while
<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from" title="tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">gen_proposal_sample_from</span></code></a> should yield samples from the proposal
distribution. While <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.propose_update" title="tracklib.analysis.neda.mcmc.MCMCScheme.propose_update"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">propose_update</span></code></a> in principle can be assembled from
these (and is by default), it usually makes sense to implement this special
case separately, since it might save computational time (significantly).</p>
<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.traj">
<code class="sig-name descname">traj</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.traj" title="Permalink to this definition">¶</a></dt>
<dd><p>the trajectory we want to find <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtraces</span></code></a> for</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory">Trajectory</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.model">
<code class="sig-name descname">model</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.model" title="Permalink to this definition">¶</a></dt>
<dd><p>the inference model to use</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model">models.Model</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.prior">
<code class="sig-name descname">prior</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.prior" title="Permalink to this definition">¶</a></dt>
<dd><p>prior over <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Looingtraces</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior">priors.Prior</a></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<p>Assume we implemented some sampling scheme <code class="docutils literal notranslate"><span class="pre">MyScheme</span></code> and have <code class="docutils literal notranslate"><span class="pre">traj</span></code>,
<code class="docutils literal notranslate"><span class="pre">model</span></code>, and <code class="docutils literal notranslate"><span class="pre">prior</span></code> defined</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MCMCconfig</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;iterations&#39;</span> <span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;burn_in&#39;</span>    <span class="p">:</span>  <span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">}</span>
<span class="gp">... </span><span class="n">mcmc</span> <span class="o">=</span> <span class="n">MyScheme</span><span class="p">()</span>
<span class="gp">... </span><span class="n">mcmc</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">prior</span><span class="p">)</span>
<span class="gp">... </span><span class="n">mcmc</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="o">**</span><span class="n">MCMCconfig</span><span class="p">)</span>
<span class="gp">... </span><span class="n">res</span> <span class="o">=</span> <span class="n">mcmc</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up everything</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – the trajectory we want to find <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtraces</span></code></a> for</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><em>models.Model</em></a>) – the inference model to use</p></li>
<li><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>priors.Prior</em></a>) – prior over <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Looingtraces</span></code></a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the MCMC sampling and store results in an <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p>
<p>The <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.model" title="tracklib.analysis.neda.mcmc.MCMCScheme.model"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">model</span></code></a> will be queried for an initial <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>.</p>
<p>All arguments are forwarded to <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler.run" title="tracklib.util.mcmc.Sampler.run"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler.run</span></code></a>, which
at the time of writing does not take any more arguments than the
initial profile.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>MCMCRun</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.acceptance_probability">
<em class="property">static </em><code class="sig-name descname">acceptance_probability</code><span class="sig-paren">(</span><em class="sig-param">L_from</em>, <em class="sig-param">L_to</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.acceptance_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate acceptance probability from two likelihoods</p>
<p>This is given by <code class="docutils literal notranslate"><span class="pre">min(1,</span> <span class="pre">exp(L_to</span> <span class="pre">-</span> <span class="pre">L_from))</span></code>. This function exists
mostly for stylistic reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>L_to</strong> (<em>L_from</em><em>,</em>) – log-likelihoods of the states we are moving from and to</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.likelihood">
<em class="property">static </em><code class="sig-name descname">likelihood</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">loopingtrace</em>, <em class="sig-param">model</em>, <em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.likelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the likelihood of the (loopingtrace, model, prior) combination</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><em>models.Model</em></a>) – </p></li>
<li><p><strong>priors</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>priors.Prior</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.logL">
<code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate log-likelihood of the given parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the parameters to use</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the log-likelihood for the given parameters.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.propose_update" title="tracklib.analysis.neda.mcmc.MCMCScheme.propose_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propose_update()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">callback_logging()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability">
<em class="property">abstract static </em><code class="sig-name descname">stepping_probability</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace_from</em>, <em class="sig-param">loopingtrace_to</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the proposal distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace_from</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the “current” <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
<li><p><strong>loopingtrace_to</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – another <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the probability that <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_to</span></code> was proposed, given that we
are currently at <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_from</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from" title="tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gen_proposal_sample_from()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from">
<em class="property">abstract static </em><code class="sig-name descname">gen_proposal_sample_from</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">nSample=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.gen_proposal_sample_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from the proposal distribution</p>
<p>This function returns a generator yielding <code class="xref any docutils literal notranslate"><span class="pre">nSample</span></code> samples from the
proposal distribution around <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>nSample</strong> (<em>float</em><em>, </em><em>optional</em>) – how many samples to draw. The default value <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code>
indicates exhaustive sampling of the distribution</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>Loopingtrace</em> – samples from the proposal distribution</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability" title="tracklib.analysis.neda.mcmc.MCMCScheme.stepping_probability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stepping_probability()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.MCMCScheme.propose_update">
<code class="sig-name descname">propose_update</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace_cur</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.MCMCScheme.propose_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Propose an update step.</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">self.stepsize</span></code> for the proposal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the current parameters</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>proposed_values</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the proposed new parameters</p></li>
<li><p><strong>logp_forward</strong> (<em>float</em>) – (log of the) probability of proposing these values from the current
ones</p></li>
<li><p><strong>logp_backward</strong> (<em>float</em>) – (log of the) probability of proposing the current values from the
proposed ones</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.logL" title="tracklib.analysis.neda.mcmc.MCMCScheme.logL"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logL()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">callback_logging()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.mcmc.TPWMCMC">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.mcmc.</code><code class="sig-name descname">TPWMCMC</code><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TPWMCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.mcmc.MCMCScheme</span></code></a></p>
<p>A time-point wise sampling scheme</p>
<p>Probably the most straight-forward sampling scheme. At each step, randomly
assign a new state for a single random frame.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.TPWMCMC.stepping_probability">
<em class="property">static </em><code class="sig-name descname">stepping_probability</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace_from</em>, <em class="sig-param">loopingtrace_to</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TPWMCMC.stepping_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the proposal distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace_from</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the “current” <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
<li><p><strong>loopingtrace_to</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – another <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the probability that <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_to</span></code> was proposed, given that we
are currently at <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace_from</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.TPWMCMC.gen_proposal_sample_from" title="tracklib.analysis.neda.mcmc.TPWMCMC.gen_proposal_sample_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gen_proposal_sample_from()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.TPWMCMC.gen_proposal_sample_from">
<em class="property">static </em><code class="sig-name descname">gen_proposal_sample_from</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">nSample=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TPWMCMC.gen_proposal_sample_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from the proposal distribution</p>
<p>This function returns a generator yielding <code class="xref any docutils literal notranslate"><span class="pre">nSample</span></code> samples from the
proposal distribution around <code class="xref any docutils literal notranslate"><span class="pre">loopingtrace</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>nSample</strong> (<em>float</em><em>, </em><em>optional</em>) – how many samples to draw. The default value <code class="docutils literal notranslate"><span class="pre">float('inf')</span></code>
indicates exhaustive sampling of the distribution</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><em>Loopingtrace</em> – samples from the proposal distribution</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.mcmc.TPWMCMC.stepping_probability" title="tracklib.analysis.neda.mcmc.TPWMCMC.stepping_probability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stepping_probability()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.mcmc.TPWMCMC.propose_update">
<code class="sig-name descname">propose_update</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace_cur</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.mcmc.TPWMCMC.propose_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Propose an update step.</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">self.stepsize</span></code> for the proposal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the current parameters</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>proposed_values</strong> (<em>&lt;user-specified parameter structure&gt;</em>) – the proposed new parameters</p></li>
<li><p><strong>logp_forward</strong> (<em>float</em>) – (log of the) probability of proposing these values from the current
ones</p></li>
<li><p><strong>logp_backward</strong> (<em>float</em>) – (log of the) probability of proposing the current values from the
proposed ones</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logL()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">callback_logging()</span></code></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.models">
<span id="tracklib-analysis-neda-models"></span><h2><a class="toc-backref" href="#id4">tracklib.analysis.neda.models</a><a class="headerlink" href="#module-tracklib.analysis.neda.models" title="Permalink to this headline">¶</a></h2>
<p>The inference models, and the interface they have to conform to.</p>
<dl class="class">
<dt id="tracklib.analysis.neda.models.Model">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.models.</code><code class="sig-name descname">Model</code><a class="headerlink" href="#tracklib.analysis.neda.models.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class for inference models</p>
<p>The most important capability of any model is the likelihood function
<a class="reference internal" href="#tracklib.analysis.neda.models.Model.logL" title="tracklib.analysis.neda.models.Model.logL"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logL</span></code></a> for a combination of <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> and <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>. Furthermore, a
model should provide an initial guess for a good <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.models.Model.initial_loopingtrace">
<em class="property">abstract </em><code class="sig-name descname">initial_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.Model.initial_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a quick guess for a good <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> for a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.Model.logL">
<em class="property">abstract </em><code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.Model.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (log-)likelihood for (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>) pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – log-likelihood associated with the inputs</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.models.RouseModel">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.models.</code><code class="sig-name descname">RouseModel</code><span class="sig-paren">(</span><em class="sig-param">N, D, k, looppositions=[(0, 0), (0, -1)], k_extra=None, measurement='end2end'</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.models.Model</span></code></a></p>
<p>Inference with Rouse models</p>
<p>This inference model uses a given number of <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></a> instances to
choose from for each propagation interval. In the default use case this
switches between a looped and unlooped model, but it could be way more
general than that, e.g. incorporating different looped states, loop
positions, numbers of loop, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>D</strong><strong>, </strong><strong>k</strong> (<em>N</em><em>,</em>) – parameters for the <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></a>. <code class="xref any docutils literal notranslate"><span class="pre">N</span></code> is the number of monomers, <code class="xref any docutils literal notranslate"><span class="pre">D</span></code>
the diffusion constant of a free monomer, <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model.k" title="tracklib.models.rouse.Model.k"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">k</span></code></a> the backbone strength.</p></li>
<li><p><strong>looppositions</strong> (<em>list of 2-tuples of int</em><em>, </em><em>optional</em>) – list of positions of the extra bond. For each entry, a new
<a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></a> instance will be set up. Remember to include an unlooped
model (if wanted) by including a position like <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>.</p></li>
<li><p><strong>k_extra</strong> (<em>float</em><em>, </em><em>optional</em>) – the strength of the extra bond. By default equal to <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model.k" title="tracklib.models.rouse.Model.k"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">k</span></code></a></p></li>
<li><p><strong>measurement</strong> (<em>&quot;end2end&quot;</em><em> or </em><em>(</em><em>N</em><em>,</em><em>) </em><em>np.ndarray</em>) – which distance to measure. The default setting “end2end” is equivalent
to specifying a vector <code class="docutils literal notranslate"><span class="pre">np.array([-1,</span> <span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">0,</span> <span class="pre">1])</span></code>, i.e. measuring
the distance from the first to the last monomer.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.models.RouseModel.models">
<code class="sig-name descname">models</code><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel.models" title="Permalink to this definition">¶</a></dt>
<dd><p>the models used for inference</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="tracklib.models.html#tracklib.models.rouse.Model" title="tracklib.models.rouse.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></a></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>By default, this model assumes that the difference between the models is
the position of the extra bond. It is easy to generalize this, by editing
the <a class="reference internal" href="#tracklib.analysis.neda.models.RouseModel.models" title="tracklib.analysis.neda.models.RouseModel.models"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">models</span></code></a> attribute after initialization. The only thing to pay
attention to is that each model needs to have a <code class="xref any docutils literal notranslate"><span class="pre">measurement</span></code> vector.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">rouse.Model</span></code></p>
</div>
<dl class="method">
<dt id="tracklib.analysis.neda.models.RouseModel.initial_loopingtrace">
<code class="sig-name descname">initial_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel.initial_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a quick guess for a good <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> for a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.RouseModel.logL">
<code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.RouseModel.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (log-)likelihood for (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>) pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – log-likelihood associated with the inputs</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.models.FactorizedModel">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.models.</code><code class="sig-name descname">FactorizedModel</code><span class="sig-paren">(</span><em class="sig-param">distributions</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.models.Model</span></code></a></p>
<p>A simplified model, assuming time scale separation</p>
<p>This model assumes that each point is sampled from one of a given list of
distributions, where there is no correlation between the choice of
distribution for each point. It runs significantly faster than the full
<a class="reference internal" href="#tracklib.analysis.neda.models.RouseModel" title="tracklib.analysis.neda.models.RouseModel"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RouseModel</span></code></a>, but is of course inaccurate if the Rouse time is longer or
comparable to the frame rate of the recorded trajectories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>distributions</strong> (<em>list of distribution objects</em>) – these will usually be <code class="docutils literal notranslate"><span class="pre">scipy.stats.rv_continuous</span></code> objects (e.g.
Maxwell), but can be pretty arbitrary. The only function they have to
provide is <code class="docutils literal notranslate"><span class="pre">logpdf()</span></code>, which should take a scalar or vector of
distance values and return a corresponding number of outputs.</p>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.models.FactorizedModel.distributions">
<code class="sig-name descname">distributions</code><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.distributions" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of distribution objects</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Instances of this class memoize trajectories they have seen before. To
reset the memoization, you can either reinstantiate or clear the cache
manually:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">FactorizedModel</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">distributions</span><span class="p">)</span>
<span class="gp">... </span><span class="n">model</span><span class="o">.</span><span class="n">clear_memo</span><span class="p">()</span>
</pre></div>
</div>
<p>If using <code class="docutils literal notranslate"><span class="pre">scipy.stats.maxwell</span></code>, make sure to use it correctly, i.e. you
have to specify <code class="docutils literal notranslate"><span class="pre">scale=...</span></code>. Writing <code class="docutils literal notranslate"><span class="pre">scipy.stats.maxwell(5)</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">scipy.stats.maxwell(scale=5)</span></code> shifts the distribution instead of
scaling it and leads to <code class="docutils literal notranslate"><span class="pre">-inf</span></code> values in the likelihood, which then screw
up the MCMC. The classic error to get for this is <code class="docutils literal notranslate"><span class="pre">invalid</span> <span class="pre">value</span>
<span class="pre">encountered</span> <span class="pre">in</span> <span class="pre">double_scalars</span></code>. This is caused by <code class="docutils literal notranslate"><span class="pre">new_logL</span> <span class="pre">-</span> <span class="pre">cur_logL</span></code>
reading <code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">inf</span> <span class="pre">+</span> <span class="pre">inf</span></code> at the first MCMC iteration, if <a class="reference internal" href="#tracklib.analysis.neda.models.FactorizedModel.logL" title="tracklib.analysis.neda.models.FactorizedModel.logL"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logL</span></code></a> returns
<code class="docutils literal notranslate"><span class="pre">-inf</span></code>.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.models.FactorizedModel.clear_memo">
<code class="sig-name descname">clear_memo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.clear_memo" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the memoization cache</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.FactorizedModel.initial_loopingtrace">
<code class="sig-name descname">initial_loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.initial_loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a quick guess for a good <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> for a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Loopingtrace</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.models.FactorizedModel.logL">
<code class="sig-name descname">logL</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em>, <em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.models.FactorizedModel.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (log-)likelihood for (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>) pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p></li>
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – log-likelihood associated with the inputs</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.neda">
<span id="tracklib-analysis-neda-neda"></span><h2><a class="toc-backref" href="#id5">tracklib.analysis.neda.neda</a><a class="headerlink" href="#module-tracklib.analysis.neda.neda" title="Permalink to this headline">¶</a></h2>
<p>Main module of the neda inference package</p>
<p>This introduces the <a class="reference internal" href="#tracklib.analysis.neda.neda.Environment" title="tracklib.analysis.neda.neda.Environment"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Environment</span></code></a> class, which we use to facilitate repeating
tasks like running MCMC, calculating or estimating evidence. Finally, the
<a class="reference internal" href="#tracklib.analysis.neda.neda.main" title="tracklib.analysis.neda.neda.main"><code class="xref any py py-func docutils literal notranslate"><span class="pre">main</span></code></a> function runs the whole scheme. Note that both of these are imported
into the <code class="docutils literal notranslate"><span class="pre">tracklib.analysis.neda</span></code> namespace, i.e. can be imported from there
(instead of <code class="docutils literal notranslate"><span class="pre">tracklib.analysis.neda.neda</span></code>).</p>
<dl class="class">
<dt id="tracklib.analysis.neda.neda.Environment">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.neda.</code><code class="sig-name descname">Environment</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">MCMCconfig</em>, <em class="sig-param">MCMCscheme=&lt;class 'tracklib.analysis.neda.mcmc.TPWMCMC'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Environment for inference runs</p>
<p>This is essentially a semi-disguised way of using global variables for the
<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> we are looking at, the inference <a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><code class="xref any py py-class docutils literal notranslate"><span class="pre">models.Model</span></code></a> we want to use, and
the <a class="reference internal" href="#tracklib.analysis.neda.neda.Environment.MCMCscheme" title="tracklib.analysis.neda.neda.Environment.MCMCscheme"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">MCMCscheme</span></code></a> together with the <a class="reference internal" href="#tracklib.analysis.neda.neda.Environment.MCMCconfig" title="tracklib.analysis.neda.neda.Environment.MCMCconfig"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">MCMCconfig</span></code></a>. We use this approach
mainly for code readability / useability.</p>
<dl class="attribute">
<dt id="tracklib.analysis.neda.neda.Environment.traj">
<code class="sig-name descname">traj</code><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.traj" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory">Trajectory</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.neda.Environment.model">
<code class="sig-name descname">model</code><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.model" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model">models.Model</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.neda.Environment.MCMCconfig">
<code class="sig-name descname">MCMCconfig</code><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.MCMCconfig" title="Permalink to this definition">¶</a></dt>
<dd><p>see <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref any py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.neda.Environment.MCMCscheme">
<code class="sig-name descname">MCMCscheme</code><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.MCMCscheme" title="Permalink to this definition">¶</a></dt>
<dd><p>this should implement the <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCScheme</span></code></a> interface (i.e. be a subclass of
this abstract base class).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>type, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.neda.Environment.runMCMC">
<code class="sig-name descname">runMCMC</code><span class="sig-paren">(</span><em class="sig-param">prior</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.runMCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the <a class="reference internal" href="#tracklib.analysis.neda.neda.Environment.MCMCscheme" title="tracklib.analysis.neda.neda.Environment.MCMCscheme"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">MCMCscheme</span></code></a> with a given <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme.prior" title="tracklib.analysis.neda.mcmc.MCMCScheme.prior"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">prior</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>mcmc.MCMCRun</em></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.neda.Environment.posterior_density">
<code class="sig-name descname">posterior_density</code><span class="sig-paren">(</span><em class="sig-param">mcmcrun</em>, <em class="sig-param">prior</em>, <em class="sig-param">trace_eval</em>, <em class="sig-param">nSample_proposal=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.posterior_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the posterior density at a specific point from an <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mcmcrun</strong> (<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><em>MCMCRun</em></a>) – </p></li>
<li><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – </p></li>
<li><p><strong>trace_eval</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – the point in parameter space for which to estimate the posterior
density</p></li>
<li><p><strong>nSample_proposal</strong> (<em>float</em><em>, </em><em>optional</em>) – how many samples from the proposal distribution to use for
evaluation of the exit rate. Defaults to exhaustive sampling, so
may be reduced if that seems excessive.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the estimated posterior density for <code class="xref any docutils literal notranslate"><span class="pre">trace_eval</span></code>. Might be
<code class="docutils literal notranslate"><span class="pre">np.inf</span></code> if the MCMC ensemble collapsed to a single sample.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This estimation follows eq. (9) of <a class="footnote-reference brackets" href="#id2" id="id1">1</a>. Essentially, we estimate the
density at the sample point as the number of times it is entered from
another point in the steady state ensemble, times the average number of
steps it takes to leave this point again, divided by the total sample
number <span class="math notranslate nohighlight">\(M\)</span>. This yields</p>
<div class="math notranslate nohighlight">
\[\hat{p}(\theta^*) = \frac{N_\text{enter}N_\text{stay}}{M} = \frac{P_\text{enter}}{k_\text{exit}} = \frac{M^{-1}\sum_{m=1}^M\, \alpha(\theta^{(m)}, \theta^*) q(\theta^{(m)}, \theta^*)}{J^{-1}\sum_{j=1}^J\, \alpha(\theta^*, \theta^{(j)})}\,,\]</div>
<p>where the <span class="math notranslate nohighlight">\(\theta^{(m)}\)</span> in the numerator are the samples from
the given MCMC run (i.e. are assumed to be sampled from the posterior
distribution), while <span class="math notranslate nohighlight">\(\theta^{(j)}\)</span> in the denominator are
independent samples from the proposal distribution
<span class="math notranslate nohighlight">\(q(\theta_\text{from} = \theta^*, \theta_\text{to})\)</span>
around the evaluation point <span class="math notranslate nohighlight">\(\theta^*\)</span>. Finally,
<span class="math notranslate nohighlight">\(\alpha(\theta_\text{from}, \theta_\text{to})\)</span> is the
acceptance probability for a given step.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Chib, S. &amp; Jeliazkov, I. Marginal Likelihood From the Metropolis-Hastings Output. Journal of the American Statistical Association 96, 270-281 (2001)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.neda.Environment.evidence">
<code class="sig-name descname">evidence</code><span class="sig-paren">(</span><em class="sig-param">prior</em>, <em class="sig-param">mcmcrun</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.evidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the (log-)evidence from an <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – the prior over <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtraces</span></code></a> used for the MCMC run</p></li>
<li><p><strong>mcmcrun</strong> (<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><em>MCMCRun</em></a>) – the MCMC sample</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the estimated log-evidence</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The log-evidence is given by <code class="docutils literal notranslate"><span class="pre">log(likelihood)</span> <span class="pre">+</span> <span class="pre">log(prior)</span> <span class="pre">-</span>
<span class="pre">log(posterior)</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.neda.Environment.posterior_density" title="tracklib.analysis.neda.neda.Environment.posterior_density"><code class="xref py py-meth docutils literal notranslate"><span class="pre">posterior_density()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.neda.Environment.evidence_differential">
<code class="sig-name descname">evidence_differential</code><span class="sig-paren">(</span><em class="sig-param">prior</em>, <em class="sig-param">ref_prior</em>, <em class="sig-param">ref_mcmcrun</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.neda.Environment.evidence_differential" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the relative evidence given a reference point</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – the prior whose evidence we want to estimate</p></li>
<li><p><strong>ref_prior</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><em>Prior</em></a>) – the reference point in prior space</p></li>
<li><p><strong>ref_mcmcrun</strong> (<a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><em>MCMCRun</em></a>) – an <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a> using the reference prior</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em> – the estimated log-evidence, relative to the reference</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The relative evidence is given by the expectation value of the prior
ratio over the MCMC sample: <code class="docutils literal notranslate"><span class="pre">E</span> <span class="pre">=</span> <span class="pre">&lt;</span> <span class="pre">prior/ref_prior</span> <span class="pre">&gt;</span></code> where <code class="docutils literal notranslate"><span class="pre">&lt;.&gt;</span></code>
indicates an average over the MCMC sample.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt>
<code class="sig-prename descclassname">tracklib.analysis.neda.neda.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">model</em>, <em class="sig-param">priorfac</em>, <em class="sig-param">MCMCconfig</em>, <em class="sig-param">MCMCscheme=&lt;class 'tracklib.analysis.neda.mcmc.TPWMCMC'&gt;</em>, <em class="sig-param">max_iterations=20</em>, <em class="sig-param">min_iterations=5</em>, <em class="sig-param">return_='nothing'</em>, <em class="sig-param">show_progress=False</em>, <em class="sig-param">assume_notebook_for_progressbar=True</em><span class="sig-paren">)</span></dt>
<dd><p>Run the neda looping inference scheme</p>
<p>The output of the inference run will be assembled into a dict whose fields
are detailed below. Where exactly this dict will end up depends on the
setting of <code class="xref any docutils literal notranslate"><span class="pre">return_</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – the <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> whose looping profile to infer</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="#tracklib.analysis.neda.models.Model" title="tracklib.analysis.neda.models.Model"><em>models.Model</em></a>) – the inference model to use</p></li>
<li><p><strong>priorfac</strong> (<a class="reference internal" href="#tracklib.analysis.neda.priors.PriorFactory" title="tracklib.analysis.neda.priors.PriorFactory"><em>PriorFactory</em></a>) – a family of priors</p></li>
<li><p><strong>MCMCconfig</strong> (<em>dict</em>) – configuration for the MCMC runs. See <a class="reference internal" href="tracklib.util.html#tracklib.util.mcmc.Sampler" title="tracklib.util.mcmc.Sampler"><code class="xref any py py-class docutils literal notranslate"><span class="pre">tracklib.util.mcmc.Sampler</span></code></a></p></li>
<li><p><strong>MCMCscheme</strong> (<em>type</em><em>, </em><em>optional</em>) – a class implementing the <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCScheme" title="tracklib.analysis.neda.mcmc.MCMCScheme"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCScheme</span></code></a> interface (i.e. a subclass of
this abstract base class). Defines the MCMC sampling scheme</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – maximum number of iterations to run</p></li>
<li><p><strong>min_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – run at least this many iterations</p></li>
<li><p><strong>return_</strong> (<em>{'nothing'</em><em>, </em><em>'None'</em><em>, </em><em>'traj'</em><em>, </em><em>'dict'}</em>) – what the return value of this function should be. Generally, the
results of the inference run will be stored in a dict. If
<code class="docutils literal notranslate"><span class="pre">return_='dict'</span></code>, that dict is directly returned. Otherwise it is
written to <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code>, and if <code class="docutils literal notranslate"><span class="pre">return_='traj'</span></code> the
trajectory is returned (useful for parallelization). Otherwise this
function returns nothing, i.e. the inference results can be accessed
simply from <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code> after calling this function.</p></li>
<li><p><strong>show_progress</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to show a progress bar. Note: for <code class="docutils literal notranslate"><span class="pre">show_progress=True</span></code> it
might happen that the termination condition is fulfilled during the
last “required” run, in which case the progress bar will stop before
reaching its maximum.</p></li>
<li><p><strong>assume_notebook_for_progressbar</strong> (<em>bool</em><em>, </em><em>optional</em>) – set to <code class="docutils literal notranslate"><span class="pre">False</span></code> if running outside Jupyter notebook to show
progressbar ASCII style</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>prior_prams</strong> (<em>np.array</em>) – the prior parameters for each iteration</p></li>
<li><p><strong>mcmcrun</strong> (<em>list of MCMCRun</em>) – the MCMC runs for each iteration</p></li>
<li><p><strong>evidence</strong> (<em>np.array</em>) – the evidence estimated from each <a class="reference internal" href="#tracklib.analysis.neda.mcmc.MCMCRun" title="tracklib.analysis.neda.mcmc.MCMCRun"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MCMCRun</span></code></a></p></li>
<li><p><strong>evidence_diff</strong> (<em>np.array</em>) – the estimated evidence differential (relative evidence) at each
iteration</p></li>
<li><p><strong>final</strong> (<em>dict</em>) – the corresponding values for the iteration that should be considered
the final result. Has entries <code class="docutils literal notranslate"><span class="pre">'prior_params'</span></code>, <code class="docutils literal notranslate"><span class="pre">'mcmcrun'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'evidence'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'iteration'</span></code> where the last one is the index of
the iteration the other three refer to.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Assuming we have a <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> <code class="docutils literal notranslate"><span class="pre">traj</span></code> that we want to run the looping
inference on:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Set up inference scheme</span>
<span class="gp">... </span><span class="n">looppositions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># 2 states: unlooped (=0), fully looped (=1)</span>
<span class="gp">... </span><span class="n">model</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">RouseModel</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">k_extra</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">looppositions</span><span class="o">=</span><span class="n">looppositions</span><span class="p">)</span>
<span class="gp">... </span><span class="n">priorfac</span> <span class="o">=</span> <span class="n">neda</span><span class="o">.</span><span class="n">priors</span><span class="o">.</span><span class="n">PriorFactory</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">... </span><span class="n">priorfac</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">logq</span> <span class="p">:</span> <span class="n">neda</span><span class="o">.</span><span class="n">priors</span><span class="o">.</span><span class="n">GeometricPrior</span><span class="p">(</span><span class="n">logq</span><span class="p">,</span> <span class="n">nStates</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">looppositions</span><span class="p">))</span>
<span class="gp">... </span><span class="n">MCMCconfig</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>        <span class="s1">&#39;iterations&#39;</span> <span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;burn_in&#39;</span>    <span class="p">:</span>  <span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">}</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Run the inference</span>
<span class="gp">... </span><span class="n">neda</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">priorfac</span><span class="p">,</span> <span class="n">MCMCconfig</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="c1"># Visualize output</span>
<span class="gp">... </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="gp">... </span><span class="n">neda</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">butterfly</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
<span class="gp">... </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.plot">
<span id="tracklib-analysis-neda-plot"></span><h2><a class="toc-backref" href="#id6">tracklib.analysis.neda.plot</a><a class="headerlink" href="#module-tracklib.analysis.neda.plot" title="Permalink to this headline">¶</a></h2>
<p>Visualizing inference runs</p>
<dl class="function">
<dt id="tracklib.analysis.neda.plot.butterfly">
<code class="sig-prename descclassname">tracklib.analysis.neda.plot.</code><code class="sig-name descname">butterfly</code><span class="sig-paren">(</span><em class="sig-param">traj, fig=None, title='Example trajectory', ylim=[0, None], ylabel='distance'</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.plot.butterfly" title="Permalink to this definition">¶</a></dt>
<dd><p>General overview over an inference run</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><em>Trajectory</em></a>) – should have <code class="docutils literal notranslate"><span class="pre">traj.meta['neda']</span></code> meta data, i.e. have gone through
<a class="reference internal" href="#tracklib.analysis.neda.neda.main" title="tracklib.analysis.neda.neda.main"><code class="xref any py py-func docutils literal notranslate"><span class="pre">neda.main</span></code></a></p></li>
<li><p><strong>fig</strong> (<em>figure handle</em><em>, </em><em>optional</em>) – the figure to plot into. Will create a new one by default</p></li>
<li><p><strong>title</strong> (<em>string</em><em>, </em><em>optional</em>) – the title for the plot</p></li>
<li><p><strong>ylim</strong> (<em>[</em><em>lower</em><em>, </em><em>higher</em><em>]</em><em>, </em><em>optional</em>) – the y-limits for the plot of the trajectory (can be used to prevent
outliers from distorting the scale)</p></li>
<li><p><strong>ylabel</strong> (<em>string</em><em>, </em><em>optional</em>) – label to attach to the y-axis of the trajectory plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.priors">
<span id="tracklib-analysis-neda-priors"></span><h2><a class="toc-backref" href="#id7">tracklib.analysis.neda.priors</a><a class="headerlink" href="#module-tracklib.analysis.neda.priors" title="Permalink to this headline">¶</a></h2>
<p>Everything to do with priors</p>
<p>This module provides two important interfaces: the <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Prior</span></code></a>, which represents a
prior distribution over <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtraces</span></code></a>, and the <a class="reference internal" href="#tracklib.analysis.neda.priors.PriorFactory" title="tracklib.analysis.neda.priors.PriorFactory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PriorFactory</span></code></a>,
which provides a framework for generating priors.</p>
<dl class="class">
<dt id="tracklib.analysis.neda.priors.Prior">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.priors.</code><code class="sig-name descname">Prior</code><a class="headerlink" href="#tracklib.analysis.neda.priors.Prior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class for priors</p>
<p>When subclassing, you need to provide the <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi" title="tracklib.analysis.neda.priors.Prior.logpi"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logpi</span></code></a> method, which should
return the (log) prior probability for an input <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>. Specifying
<a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi_vectorized" title="tracklib.analysis.neda.priors.Prior.logpi_vectorized"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logpi_vectorized</span></code></a> is optional, if you can speed up the prior calculation
over an iterable of loopingtraces.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.priors.Prior.logpi">
<em class="property">abstract </em><code class="sig-name descname">logpi</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.Prior.logpi" title="Permalink to this definition">¶</a></dt>
<dd><p>log of prior probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi_vectorized" title="tracklib.analysis.neda.priors.Prior.logpi_vectorized"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi_vectorized()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.priors.Prior.logpi_vectorized">
<code class="sig-name descname">logpi_vectorized</code><span class="sig-paren">(</span><em class="sig-param">loopingtraces</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.Prior.logpi_vectorized" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior on multiple loopingtraces</p>
<p>By default just sequentially evaluates <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi" title="tracklib.analysis.neda.priors.Prior.logpi"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logpi</span></code></a> on the given
loopingtraces, which of course does not give a speedup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtraces</strong> (<em>Sequence</em><em> (</em><em>e.g. list</em><em>) </em><em>of Loopingtrace</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>np.ndarray, dtype=float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.Prior.logpi" title="tracklib.analysis.neda.priors.Prior.logpi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.priors.PriorFactory">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.priors.</code><code class="sig-name descname">PriorFactory</code><span class="sig-paren">(</span><em class="sig-param">start_params</em>, <em class="sig-param">bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.PriorFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A factory class for priors</p>
<p>This class encodes usage patterns for priors. To that end, it stores a
reasonable set of default/initial parametrs for the given prior, as well as
the domains for each prior. It then also provides a method to convert a set
of parameters to a <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Prior</span></code></a> object. In summary, this class provides
everything we need to run a generic fitting algorithm over priors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_params</strong> (<em>tuple of float</em>) – the initial/default parameters for a given class of priors</p></li>
<li><p><strong>bounds</strong> (<em>list of</em><em> (</em><em>lower</em><em>, </em><em>higher</em><em>) </em><em>tuples</em>) – domain for each parameter</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.priors.PriorFactory.start_params">
<code class="sig-name descname">start_params</code><a class="headerlink" href="#tracklib.analysis.neda.priors.PriorFactory.start_params" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple of float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.priors.PriorFactory.nParams">
<code class="sig-name descname">nParams</code><a class="headerlink" href="#tracklib.analysis.neda.priors.PriorFactory.nParams" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.priors.PriorFactory.bounds">
<code class="sig-name descname">bounds</code><a class="headerlink" href="#tracklib.analysis.neda.priors.PriorFactory.bounds" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of (lower, higher) tuples</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Example</p>
<p>A factory for <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior" title="tracklib.analysis.neda.priors.GeometricPrior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GeometricPrior</span></code></a> (with 2 states):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">priorfac</span> <span class="o">=</span> <span class="n">PriorFactory</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">... </span><span class="n">priorfac</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">logq</span> <span class="p">:</span> <span class="n">GeometricPrior</span><span class="p">(</span><span class="n">logq</span><span class="p">)</span>
<span class="gp">... </span><span class="n">priorfac</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">GeometricPrior</span> <span class="c1"># also works in this special case, but suboptimal style</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior" title="tracklib.analysis.neda.priors.GeometricPrior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GeometricPrior</span></code></a> also has a <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior.factory" title="tracklib.analysis.neda.priors.GeometricPrior.factory"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">factory</span></code></a> method providing
essentially this construction.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Prior</span></code></a></p>
</div>
<dl class="method">
<dt id="tracklib.analysis.neda.priors.PriorFactory.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param">*params</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.PriorFactory.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a prior from the given parameters</p>
<p>This function should be overwritten upon instantiation</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.priors.UniformPrior">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.priors.</code><code class="sig-name descname">UniformPrior</code><a class="headerlink" href="#tracklib.analysis.neda.priors.UniformPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.priors.Prior</span></code></a></p>
<p>A uniform prior over loopingtraces</p>
<p>This is simply <span class="math notranslate nohighlight">\(-N\log(n)\)</span> for each <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a>, where <span class="math notranslate nohighlight">\(n\)</span>
is the number of states and <span class="math notranslate nohighlight">\(N\)</span> the number of (valid) frames.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.priors.UniformPrior.logpi">
<code class="sig-name descname">logpi</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.UniformPrior.logpi" title="Permalink to this definition">¶</a></dt>
<dd><p>log of prior probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi_vectorized()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tracklib.analysis.neda.priors.GeometricPrior">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.priors.</code><code class="sig-name descname">GeometricPrior</code><span class="sig-paren">(</span><em class="sig-param">logq=0</em>, <em class="sig-param">nStates=2</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tracklib.analysis.neda.priors.Prior" title="tracklib.analysis.neda.priors.Prior"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracklib.analysis.neda.priors.Prior</span></code></a></p>
<p>A geometric prior over #switches in the <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a></p>
<p>Writing <span class="math notranslate nohighlight">\(\theta\)</span> for the <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> and <span class="math notranslate nohighlight">\(k(\theta)\)</span> for the
number of switches therein, this is given by</p>
<div class="math notranslate nohighlight">
\[\pi(\theta) = \frac{1}{n}(1+(n-1)q)^{N-1} q^{k(\theta)}\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(q\in(0, 1]\)</span> is the one parameter of this prior, <span class="math notranslate nohighlight">\(n\)</span> is
the number of possible states and <span class="math notranslate nohighlight">\(N\)</span> is the number of (valid) frames
in the trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logq</strong> (<em>float &lt; 0</em>) – log of the parameter q</p></li>
<li><p><strong>nStates</strong> (<em>int</em><em>, </em><em>optional</em>) – the number of possible states</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.logq">
<code class="sig-name descname">logq</code><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.logq" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.n">
<code class="sig-name descname">n</code><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.n" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.logpi">
<code class="sig-name descname">logpi</code><span class="sig-paren">(</span><em class="sig-param">loopingtrace</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi" title="Permalink to this definition">¶</a></dt>
<dd><p>log of prior probability</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtrace</strong> (<a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><em>Loopingtrace</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi_vectorized" title="tracklib.analysis.neda.priors.GeometricPrior.logpi_vectorized"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi_vectorized()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.logpi_vectorized">
<code class="sig-name descname">logpi_vectorized</code><span class="sig-paren">(</span><em class="sig-param">loopingtraces</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi_vectorized" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior on multiple loopingtraces</p>
<p>By default just sequentially evaluates <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi" title="tracklib.analysis.neda.priors.GeometricPrior.logpi"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">logpi</span></code></a> on the given
loopingtraces, which of course does not give a speedup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loopingtraces</strong> (<em>Sequence</em><em> (</em><em>e.g. list</em><em>) </em><em>of Loopingtrace</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>np.ndarray, dtype=float</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior.logpi" title="tracklib.analysis.neda.priors.GeometricPrior.logpi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logpi()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.priors.GeometricPrior.factory">
<em class="property">classmethod </em><code class="sig-name descname">factory</code><span class="sig-paren">(</span><em class="sig-param">nStates=2</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.priors.GeometricPrior.factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a <a class="reference internal" href="#tracklib.analysis.neda.priors.PriorFactory" title="tracklib.analysis.neda.priors.PriorFactory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PriorFactory</span></code></a> for <a class="reference internal" href="#tracklib.analysis.neda.priors.GeometricPrior" title="tracklib.analysis.neda.priors.GeometricPrior"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GeometricPrior</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nStates</strong> (<em>int</em><em>, </em><em>optional</em>) – the number of states the priors will assume</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>PriorFactory</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.priors.PriorFactory" title="tracklib.analysis.neda.priors.PriorFactory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PriorFactory()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tracklib.analysis.neda.util">
<span id="tracklib-analysis-neda-util"></span><h2><a class="toc-backref" href="#id8">tracklib.analysis.neda.util</a><a class="headerlink" href="#module-tracklib.analysis.neda.util" title="Permalink to this headline">¶</a></h2>
<p>Useful constructs used throughout the <a class="reference internal" href="#module-tracklib.analysis.neda.neda" title="tracklib.analysis.neda.neda"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">neda</span></code></a> module</p>
<dl class="class">
<dt id="tracklib.analysis.neda.util.Loopingtrace">
<em class="property">class </em><code class="sig-prename descclassname">tracklib.analysis.neda.util.</code><code class="sig-name descname">Loopingtrace</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">nStates=2</em>, <em class="sig-param">thresholds=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Trace of looping states</p>
<p><a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> objects associate an integer state with each valid (i.e.
non-<code class="docutils literal notranslate"><span class="pre">nan</span></code>) time point in a given trajectory. To this end, it keeps a list
of those valid time points alongside the list of states.</p>
<p>In the context of looping inference, the states indicate which out of a
list of models to use for evolution up to the labelled point. For the first
data point this means that the associated model specifies the equilibrium
state we start from.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>traj</strong> (<em>tracklib.Trajectory</em>) – the <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a> to which the <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> is associated. This
information is needed to assemble the list of valid time points.</p></li>
<li><p><strong>nStates</strong> (<em>int</em><em>, </em><em>optional</em>) – the number of possible states</p></li>
<li><p><strong>thresholds</strong> (<em>sized iterable</em><em> (</em><em>e.g. list</em><em>) </em><em>of float</em><em>, </em><em>optional</em>) – can be used to initialize the trajectory with states corresponding to a
set of absolute distance thresholds. The state of each frame will be
the number of given thresholds that are smaller than the absolute
distance, i.e. <code class="docutils literal notranslate"><span class="pre">thresholds=[5,</span> <span class="pre">10]</span></code> means <code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">&lt;=</span> <span class="pre">5</span></code> is state 0,
<code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">&lt;</span> <span class="pre">dist</span> <span class="pre">&lt;=</span> <span class="pre">10</span></code> state 1, <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">&lt;</span> <span class="pre">dist</span></code> state 2. Will overwrite
<code class="xref any docutils literal notranslate"><span class="pre">nStates</span></code> with <code class="docutils literal notranslate"><span class="pre">len(thresholds)+1</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="tracklib.analysis.neda.util.Loopingtrace.T">
<code class="sig-name descname">T</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.T" title="Permalink to this definition">¶</a></dt>
<dd><p>total length of the associated <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.util.Loopingtrace.n">
<code class="sig-name descname">n</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.n" title="Permalink to this definition">¶</a></dt>
<dd><p>total number of states (relevant e.g. for acceptance probabilities)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.util.Loopingtrace.t">
<code class="sig-name descname">t</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.t" title="Permalink to this definition">¶</a></dt>
<dd><p>valid frames of the associated <a class="reference internal" href="tracklib.html#tracklib.trajectory.Trajectory" title="tracklib.trajectory.Trajectory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(N,) np.ndarray, dtype=int</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="tracklib.analysis.neda.util.Loopingtrace.state">
<code class="sig-name descname">state</code><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.state" title="Permalink to this definition">¶</a></dt>
<dd><p>state associated with each (valid) frame of the trajectory. By default
initialized with zeroes, unless <code class="xref any docutils literal notranslate"><span class="pre">thresholds</span></code> specified</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(N,) np.ndarray, dtype=int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This class forwards the <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> interface of its <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace.state" title="tracklib.analysis.neda.util.Loopingtrace.state"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">state</span></code></a> attribute,
i.e. for a <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> <code class="docutils literal notranslate"><span class="pre">lt</span></code> <code class="docutils literal notranslate"><span class="pre">len(lt)</span></code> gives the number of valid
frames, <code class="docutils literal notranslate"><span class="pre">lt[i]</span></code> gives the state associated with the <code class="docutils literal notranslate"><span class="pre">i``th</span> <span class="pre">valid</span> <span class="pre">frame</span>
<span class="pre">and</span> <span class="pre">``lt[i]</span> <span class="pre">=</span> <span class="pre">2</span></code> can be used to assign that state. Note that this usage is
preferred over accessing <code class="docutils literal notranslate"><span class="pre">lt.state</span></code>, since it allows for more internal
control, such as type checks upon assignment.</p>
<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy myself</p>
<p>Creates a copy of the calling object. Faster than
<code class="docutils literal notranslate"><span class="pre">deepcopy(loopingtrace)</span></code>, i.e. used for performance.</p>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.plottable">
<code class="sig-name descname">plottable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.plottable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return t, y for plotting as steps</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>t</strong> (<em>np.ndarray</em>)</p></li>
<li><p><strong>y</strong> (<em>np.ndarray</em>)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>For a <a class="reference internal" href="#tracklib.analysis.neda.util.Loopingtrace" title="tracklib.analysis.neda.util.Loopingtrace"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Loopingtrace</span></code></a> <code class="docutils literal notranslate"><span class="pre">lt</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="gp">... </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">lt</span><span class="o">.</span><span class="n">plottable</span><span class="p">(),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tracklib.analysis.neda.util.Loopingtrace.full_valid">
<code class="sig-name descname">full_valid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tracklib.analysis.neda.util.Loopingtrace.full_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a full-length array of states</p>
<p>This returns an array of looping states of length equal to the
associated trajectory. Invalid frames in the trajectory (i.e. those
containing <code class="docutils literal notranslate"><span class="pre">nan</span></code>) will be labelled with the same state as the next
valid one. This implements the interpretation that the state associated
with a frame specifies the model governing the evolution up to that
frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>states</strong> (<em>(self.T,) np.ndarray</em>) – a valid states associated with each frame in the trajectory, even
the invalid ones.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">tracklib.analysis.neda</a><ul>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.mcmc">tracklib.analysis.neda.mcmc</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.models">tracklib.analysis.neda.models</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.neda">tracklib.analysis.neda.neda</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.plot">tracklib.analysis.neda.plot</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.priors">tracklib.analysis.neda.priors</a></li>
<li><a class="reference internal" href="#module-tracklib.analysis.neda.util">tracklib.analysis.neda.util</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tracklib.analysis.html"
                        title="previous chapter">tracklib.analysis</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tracklib.io.html"
                        title="next chapter">tracklib.io</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tracklib.analysis.neda.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tracklib.io.html" title="tracklib.io"
             >next</a> |</li>
        <li class="right" >
          <a href="tracklib.analysis.html" title="tracklib.analysis"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">tracklib 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tracklib.html" >tracklib</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tracklib.analysis.html" >tracklib.analysis</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Simon Grosse-Holz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>